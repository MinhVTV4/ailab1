<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Lab - Vẽ Phân tử 2D từ SMILES</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase Core (luôn cần thiết) -->
    <script type="module" src="https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js"></script>
    <!-- Firebase Authentication -->
    <script type="module" src="https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js"></script>
    <!-- Firebase Firestore -->
    <script type="module" src="https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js"></script>
    <!-- Firebase AI Logic SDK -->
    <script type="module" src="https://www.gstatic.com/firebasejs/11.8.1/firebase-ai.js"></script>
    <!-- Konva.js -->
    <script src="https://unpkg.com/konva@9.3.6/konva.min.js"></script>
    <!-- NEW: Smiles-Drawer library for drawing molecules -->
    <script src="https://unpkg.com/smiles-drawer@2.0.1/dist/smiles-drawer.min.js"></script>
    <style>
        body { font-family: sans-serif; overscroll-behavior: none; }
        #konva-stage-container canvas { max-width: 100%; height: auto !important; }
        .custom-toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: #333; color: white; padding: 10px 20px; border-radius: 5px; z-index: 1000; opacity: 0; transition: opacity 0.5s ease-in-out; pointer-events: none; }
        .custom-toast.show { opacity: 1; }
        /* Style cho form xác thực */
        .auth-form-container { max-width: 400px; margin: 2rem auto; padding: 2rem; background-color: white; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .lab-hidden { display: none !important; } /* Ẩn phòng thí nghiệm khi chưa đăng nhập */
        .api-error-notice { background-color: #fff3cd; border-color: #ffeeba; color: #856404; padding: .75rem 1.25rem; margin-bottom: 1rem; border: 1px solid transparent; border-radius: .25rem; }
         .info-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            background-color: white;
            border-radius: 0.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            padding: 1.5rem;
            max-width: 90%;
            width: 500px;
            z-index: 5000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            max-height: 80vh; /* Giới hạn chiều cao */
            overflow-y: auto; /* Thêm cuộn nếu nội dung dài */
        }
        .info-panel.hidden {
            display: none;
        }
        .info-panel-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 4999;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .info-panel-overlay.hidden {
            display: none;
        }
        .confirm-modal {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 4000;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .confirm-modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 400px;
        }
        /* NEW: Styles for smaller chemical cards */
        #userChemicalsContainer .chemical-card {
            padding: 0.4rem; /* Reduced padding */
            font-size: 0.75rem; /* Base font size */
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            height: 90px; /* Reduced fixed height */
            justify-content: space-between;
        }
        #userChemicalsContainer .chemical-card h4 {
            font-size: 0.75rem; /* Smaller font size for name */
            margin-bottom: 0.25rem;
            flex-shrink: 0;
            margin-top: 0.5rem; /* Pushed down to avoid buttons */
            line-height: 1.2; /* Tighter line height */
            max-height: 2.4em; /* Limit to 2 lines */
            overflow: hidden; /* Hide overflow */
            text-overflow: ellipsis; /* Add ellipsis if overflow */
        }
        #userChemicalsContainer .chemical-card p {
            font-size: 1.125rem; /* Larger font size for formula */
            font-weight: bold; /* Make formula bold */
            margin-bottom: auto;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center; /* Center formula horizontally */
        }
        /* Responsive grid for chemical cards */
        #userChemicalsContainer {
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.4rem;
        }
        @media (min-width: 640px) { /* sm */
            #userChemicalsContainer {
                grid-template-columns: repeat(auto-fill, minmax(85px, 1fr));
            }
        }
        @media (min-width: 768px) { /* md */
            #userChemicalsContainer {
                grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            }
        }
        @media (min-width: 1024px) { /* lg */
            #userChemicalsContainer {
                grid-template-columns: repeat(auto-fill, minmax(95px, 1fr));
            }
        }
        @media (min-width: 1280px) { /* xl */
            #userChemicalsContainer {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            }
        }

        /* Tooltip styles */
        .chemical-tooltip {
            position: absolute;
            top: calc(100% + 5px);
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0; /* Square tooltip */
            font-size: 0.75rem;
            white-space: normal;
            max-width: 250px;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease-in-out, visibility 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            text-align: left;
        }
        .chemical-card:hover .chemical-tooltip {
            opacity: 1;
            visibility: visible;
        }
        .chemical-tooltip::before {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent rgba(0, 0, 0, 0.85) transparent;
        }

        /* NEW: Type Indicator and Info Button Styles */
        .type-indicator {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            border-top-left-radius: 0.25rem;
            border-top-right-radius: 0.25rem;
        }
        .info-icon-btn {
            position: absolute;
            top: 0.25rem;
            left: 0.25rem;
            background-color: rgba(255, 255, 255, 0.7);
            color: #4B5563;
            border-radius: 9999px;
            width: 1.25rem;
            height: 1.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.9;
            transition: opacity 0.15s ease-in-out;
            z-index: 10;
            cursor: pointer;
        }
        .info-icon-btn:hover {
            opacity: 1;
            background-color: rgba(255, 255, 255, 1);
        }
        .info-icon-btn svg {
            width: 0.75rem;
            height: 0.75rem;
        }
        .delete-btn {
            z-index: 10;
            top: 0.25rem;
            right: 0.25rem;
        }
        /* NEW: Thermometer styling */
        .thermometer-container {
            position: absolute;
            width: 30px;
            height: 100px;
            background-color: #ccc;
            border-radius: 15px 15px 5px 5px;
            border: 2px solid #666;
            overflow: hidden;
            left: 20px; /* Example position */
            top: 20px; /* Example position */
            z-index: 100;
        }
        .thermometer-bulb {
            width: 40px;
            height: 40px;
            background-color: red;
            border-radius: 50%;
            position: absolute;
            bottom: -10px;
            left: -5px;
        }
        .thermometer-mercury {
            position: absolute;
            width: 10px;
            background-color: red;
            bottom: 0;
            left: 10px;
            border-radius: 0 0 5px 5px;
        }

        /* NEW: Countdown timer styles */
        #reaction-timer {
            font-size: 1.2rem;
            font-weight: bold;
            color: #d9534f;
            margin-top: 10px;
            text-align: center;
        }
        /* New: Safety Alert styles */
        .safety-alert {
            background-color: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #f5c6cb;
            margin-bottom: 15px;
            font-weight: bold;
            text-align: center;
        }

        /* Styling for the tool container */
        #tools-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 8px;
            margin-bottom: 15px;
            justify-content: center;
        }

        .tool-item {
            background-color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: grab;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 5px;
            border: 1px solid #ccc;
            transition: all 0.2s ease-in-out;
        }

        .tool-item:hover {
            background-color: #d0d0d0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .tool-item:active {
            cursor: grabbing;
            transform: scale(0.98);
        }

        .tool-item svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }
        
        .temp-display {
            font-size: 0.9rem;
            font-weight: bold;
            color: #d9534f;
            text-align: center;
            margin-top: 5px;
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Khu vực Xác thực -->
    <div id="auth-container" class="min-h-screen flex flex-col items-center justify-center p-4">
        <div class="w-full max-w-md mb-4 p-3 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700">
            <p class="font-bold">Lưu ý quan trọng:</p>
            <p>1. Để sử dụng chức năng đăng nhập/đăng ký bằng Email, bạn cần kích hoạt phương thức "Email/Password" trong Firebase Console -> Authentication -> Sign-in method.</p>
            <p class="mt-2">2. Để chức năng "Tạo Hóa Chất" hoạt động, hãy đảm bảo dịch vụ "Generative Language API" (hoặc Vertex AI) đã được bật cho dự án của bạn trong Google Cloud Console.</p>
        </div>
        <div id="user-status" class="w-full max-w-md mb-4 p-3 bg-white rounded shadow text-center">
            <p id="user-email-display">Chưa đăng nhập</p>
            <button id="signOutButton" class="hidden mt-2 bg-red-500 hover:bg-red-600 text-white font-semibold py-1 px-3 rounded text-sm">Đăng xuất</button>
        </div>

        <div id="login-form-container" class="auth-form-container">
            <h2 class="text-2xl font-bold text-blue-700 text-center mb-6">Đăng Nhập</h2>
            <input type="email" id="loginEmail" placeholder="Email" class="w-full p-2 mb-3 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500">
            <input type="password" id="loginPassword" placeholder="Mật khẩu" class="w-full p-2 mb-4 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500">
            <button id="loginButton" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded mb-2">Đăng Nhập</button>
            <p class="text-center text-sm">Chưa có tài khoản? <a href="#" id="showRegisterLink" class="text-blue-600 hover:underline">Đăng ký ngay</a></p>
        </div>

        <div id="register-form-container" class="auth-form-container hidden">
            <h2 class="text-2xl font-bold text-green-700 text-center mb-6">Đăng Ký</h2>
            <input type="email" id="registerEmail" placeholder="Email" class="w-full p-2 mb-3 border border-gray-300 rounded focus:ring-2 focus:ring-green-500">
            <input type="password" id="registerPassword" placeholder="Mật khẩu (ít nhất 6 ký tự)" class="w-full p-2 mb-4 border border-gray-300 rounded focus:ring-2 focus:ring-green-500">
            <button id="registerButton" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded mb-2">Đăng Ký</button>
            <p class="text-center text-sm">Đã có tài khoản? <a href="#" id="showLoginLink" class="text-green-600 hover:underline">Đăng nhập</a></p>
        </div>
    </div>

    <!-- Khu vực Phòng Thí Nghiệm (ban đầu bị ẩn) -->
    <div id="lab-section" class="lab-hidden p-4 md:p-8">
        <h1 class="text-2xl md:text-3xl font-bold text-blue-700 text-center mb-6">Phòng Thí Nghiệm Mô Phỏng AI</h1>

        <div class="mb-6 p-4 bg-white rounded shadow">
            <h3 class="text-xl font-semibold text-gray-700 mb-3">Tạo Hóa Chất Mới (AI Hỗ Trợ)</h3>
            <div id="gemini-api-error-notice" class="api-error-notice hidden">
                <p class="font-bold">Lỗi kết nối Gemini API!</p>
                <p>Vui lòng kiểm tra cấu hình dự án Firebase của bạn và đảm bảo dịch vụ Generative Language API đã được bật trên Google Cloud Console.</p>
            </div>
            <div class="flex gap-2">
                <input type="text" id="chemicalNameInput" placeholder="Nhập tên hóa chất (ví dụ: Axit Sunfuric)" class="flex-grow p-2 border border-gray-300 rounded focus:ring-2 focus:ring-indigo-500">
                <button id="createChemicalButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded">Tạo Hóa Chất</button>
            </div>
        </div>

        <!-- NEW: Button to toggle Experiment Management Section -->
        <div class="mb-6">
            <button id="toggleExperimentManagementButton" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150">
                <span id="toggleExperimentText">Mở Quản Lý Thí Nghiệm</span>
            </button>
        </div>

        <!-- NEW SECTION: Quản lý Thí Nghiệm (hidden by default) -->
        <div id="experimentManagementSection" class="mb-6 p-4 bg-white rounded shadow hidden">
            <h3 class="text-xl font-semibold text-gray-700 mb-3">Quản Lý Thí Nghiệm</h3>
            <div class="flex gap-2 mb-4">
                <input type="text" id="experimentNameInput" placeholder="Nhập tên thí nghiệm" class="flex-grow p-2 border border-gray-300 rounded focus:ring-2 focus:ring-purple-500">
                <button id="saveExperimentButton" class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded">Lưu Thí Nghiệm Hiện Tại</button>
            </div>
            <h4 class="text-lg font-semibold text-gray-700 mb-2">Các Thí Nghiệm Đã Lưu:</h4>
            <div id="userExperimentsContainer" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-3 min-h-[100px] bg-gray-50 p-2 rounded border">
                <p class="text-gray-500 col-span-full text-center py-4">Bạn chưa lưu thí nghiệm nào.</p>
            </div>
            <!-- NEW: Experiment Suggestion Section -->
            <div class="mt-6 p-4 bg-gray-50 rounded border">
                <h4 class="text-lg font-semibold text-gray-700 mb-3">Gợi ý thí nghiệm từ AI:</h4>
                <div class="flex gap-2 mb-2">
                    <input type="text" id="experimentSuggestionPrompt" placeholder="Ví dụ: Phản ứng tỏa nhiệt, kết tủa trắng" class="flex-grow p-2 border border-gray-300 rounded focus:ring-2 focus:ring-purple-500">
                    <button id="suggestExperimentButton" class="bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded">Gợi ý</button>
                </div>
                <div id="experimentSuggestionResults" class="min-h-[50px] text-sm text-gray-600">
                    <!-- Results will be displayed here -->
                </div>
            </div>
        </div>
        <!-- END NEW SECTION -->

        <div class="mb-6 p-4 bg-white rounded shadow">
            <h3 class="text-xl font-semibold text-gray-700 mb-3">Hóa Chất Của Bạn</h3>
            <!-- NEW: Search Input for Chemicals -->
            <div class="mb-4">
                <input type="text" id="chemicalSearchInput" placeholder="Tìm kiếm hóa chất (tên, công thức, loại...)" class="w-full p-2 border border-gray-300 rounded focus:ring-2 focus:ring-green-500">
            </div>
            <div id="userChemicalsContainer" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-2 min-h-[100px] bg-gray-50 p-2 rounded border">
                <p class="text-gray-500 col-span-full text-center py-4">Bạn chưa lưu hóa chất nào.</p>
            </div>
        </div>

        <!-- NEW: Tools container -->
        <div class="mb-6 p-4 bg-white rounded shadow">
            <h3 class="text-xl font-semibold text-gray-700 mb-3">Công cụ phòng thí nghiệm</h3>
            <div id="tools-container">
                <div class="tool-item" data-tool-type="thermometer">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M14 6V1H10V6H14ZM12 21C14.7614 21 17 18.7614 17 16C17 13.9882 15.6599 12.2858 13.7915 11.6067C14.5492 10.966 15 10.0381 15 9C15 7.34315 13.6569 6 12 6C10.3431 6 9 7.34315 9 9C9 10.0381 9.45083 10.966 10.2085 11.6067C8.34014 12.2858 7 13.9882 7 16C7 18.7614 9.23858 21 12 21ZM12 19C10.3431 19 9 17.6569 9 16C9 14.8954 9.67134 13.9452 10.6558 13.4339C11.1394 13.2083 11.7583 13.0906 12.336 13.0645C12.4452 13.0594 12.5548 13.0594 12.664 13.0645C13.2417 13.0906 13.8606 13.2083 14.3442 13.4339C15.3287 13.9452 16 14.8954 16 16C16 17.6569 14.6569 19 13 19H12ZM12 17C12.5523 17 13 16.5523 13 16C13 15.4477 12.5523 15 12 15C11.4477 15 11 15.4477 11 16C11 16.5523 11.4477 17 12 17Z" /><path d="M12 7C12.5523 7 13 7.44772 13 8C13 8.55228 12.5523 9 12 9C11.4477 9 11 8.55228 11 8C11 7.44772 11.4477 7 12 7Z"/></svg>
                    Nhiệt kế
                </div>
                <div class="tool-item" data-tool-type="burner">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2ZM12 20C7.58172 20 4 16.4183 4 12C4 7.58172 7.58172 4 12 4C16.4183 4 20 7.58172 20 12C20 16.4183 16.4183 20 12 20ZM12 8C10.8954 8 10 8.89543 10 10C10 11.1046 10.8954 12 12 12C13.1046 12 14 11.1046 14 10C14 8.89543 13.1046 8 12 8ZM12 14C10.8954 14 10 14.8954 10 16C10 17.1046 10.8954 18 12 18C13.1046 18 14 17.1046 14 16C14 14.8954 13.1046 14 12 14Z"/></svg>
                    Đèn cồn
                </div>
                <div class="tool-item" data-tool-type="test-tube">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M18 2H6C5.44772 2 5 2.44772 5 3V21C5 21.5523 5.44772 22 6 22H18C18.5523 22 19 21.5523 19 21V3C19 2.44772 18.5523 2 18 2ZM7 4H17V20H7V4Z"/></svg>
                    Ống nghiệm
                </div>
                <div class="tool-item" data-tool-type="erlenmeyer">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24"><path d="M19 2H5C4.44772 2 4 2.44772 4 3V21C4 21.5523 4.44772 22 5 22H19C19.5523 22 20 21.5523 20 21V3C20 2.44772 19.5523 2 19 2ZM6 4H18V20H6V4Z"/></svg>
                    Bình tam giác
                </div>
                <!-- You can add more tools here following the same structure -->
            </div>
        </div>

        <div id="lab-container" class="flex flex-col md:flex-row md:justify-around w-full max-w-6xl mx-auto gap-4">
            <div id="konva-outer-container" class="w-full md:w-2/3 bg-gray-200 border border-gray-300 rounded-lg shadow p-2 flex justify-center items-center touch-none relative">
                <div id="konva-stage-container"></div>
                <!-- NEW: Countdown timer display -->
                <div id="reaction-timer" class="absolute bottom-2 left-1/2 -translate-x-1/2 hidden"></div>
                 <!-- NEW: Temperature Display -->
                <div id="beaker-temperature-display" class="temp-display absolute top-4 right-4 hidden"></div>
            </div>

            <div id="ai-controls-container" class="w-full md:w-1/3 flex flex-col bg-white p-4 border border-gray-300 rounded-lg shadow">
                <h2 class="text-xl font-semibold text-blue-600 mb-3">Kết quả & Tương tác AI</h2>
                <div id="safety-alert-container" class="safety-alert hidden"></div>
                <h3 class="text-lg font-semibold text-blue-600 mb-2">Phản hồi từ Gemini:</h3>
                <div id="responseContainer" class="p-3 border border-gray-200 bg-gray-50 rounded-md min-h-[150px] whitespace-pre-wrap flex-grow overflow-y-auto mb-4">
                    Chưa có phản hồi...
                </div>
                <h3 class="text-lg font-semibold text-gray-700 mb-2">Gửi lời nhắc thủ công:</h3>
                <div id="controls" class="flex flex-col">
                    <textarea id="promptInput" rows="3" placeholder="Nhập lời nhắc thủ công ở đây..." class="w-full p-2 border border-gray-300 rounded-md mb-2 focus:ring-2 focus:ring-blue-500 focus:border-transparent"></textarea>
                    <button id="sendPromptButtonLab" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded mb-2">Gửi tới Gemini (Thí nghiệm)</button>
                </div>
                <button id="resetBeakerButton" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md transition duration-150 mt-4">Làm sạch cốc</button>
            </div>
        </div>
    </div>
    <div id="customToast" class="custom-toast"></div>

    <div id="confirmSaveModal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-40 flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg shadow-xl w-11/12 md:w-1/3">
            <h3 class="text-xl font-bold mb-4">Xác nhận Lưu Hóa Chất</h3>
            <div id="confirmChemicalDetails" class="mb-4 text-sm max-h-60 overflow-y-auto">
                {/* Chi tiết hóa chất từ AI sẽ được chèn vào đây */}
            </div>
            <p class="mb-4">Bạn có muốn lưu hóa chất này vào kho lưu trữ cá nhân không?</p>
            <div class="flex justify-end gap-3">
                <button id="cancelSaveChemical" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded">Hủy</button>
                <button id="confirmSaveChemicalButtonAction" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded">Lưu</button>
            </div>
        </div>
    </div>

    <!-- Info Panel cho hóa chất -->
    <div id="info-panel-overlay" class="info-panel-overlay hidden"></div>
    <div id="info-panel" class="info-panel hidden">
        <button id="info-panel-close-x" class="absolute top-2 right-2 text-gray-500 hover:text-gray-800 text-xl font-bold">&times;</button>
        <h3 id="info-panel-title" class="text-2xl font-bold mb-3 text-blue-700"></h3>
        <div id="info-panel-description" class="text-gray-700 text-base leading-relaxed"></div>
        
        <!-- NEW: Section for 2D Molecule Drawing -->
        <h4 class="font-semibold mt-4 mb-2 text-gray-700">Cấu trúc phân tử 2D:</h4>
        <div id="molecule-drawing-container" class="bg-white p-2 rounded border border-gray-300 flex justify-center items-center min-h-[200px]">
            <canvas id="molecule-canvas" width="300" height="300"></canvas>
            <p id="smiles-not-found" class="text-gray-500 hidden">Không tìm thấy mã SMILES để vẽ cấu trúc.</p>
        </div>
        
        <button id="info-panel-close-button" class="mt-6 bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md w-full">Đóng</button>
    </div>

    <!-- Modal xác nhận xóa thí nghiệm -->
    <div id="confirmDeleteExperimentModal" class="confirm-modal hidden">
        <div class="confirm-modal-content">
            <h3 class="text-xl font-bold mb-4">Xác nhận xóa thí nghiệm</h3>
            <p id="confirmDeleteExperimentText" class="mb-4">Bạn có chắc chắn muốn xóa thí nghiệm "<span class="font-semibold" id="experimentToDeleteName"></span>" không?</p>
            <div class="flex justify-end gap-3">
                <button id="cancelDeleteExperiment" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-2 px-4 rounded">Hủy</button>
                <button id="confirmDeleteExperiment" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded">Xóa</button>
            </div>
        </div>
    </div>


    <script type="module">
        // Import functions from Firebase SDK
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
        import {
            getAuth,
            createUserWithEmailAndPassword,
            signInWithEmailAndPassword,
            signOut,
            onAuthStateChanged,
            setPersistence,
            browserLocalPersistence
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
        import {
            getFirestore,
            doc,
            setDoc,
            getDoc,
            addDoc,
            collection,
            query,
            where,
            getDocs,
            onSnapshot,
            serverTimestamp,
            deleteDoc
        } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";
        import { getAI, getGenerativeModel, GoogleAIBackend } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-ai.js";


        const firebaseConfig = {
            apiKey: "AIzaSyAnWoc5pBabK2OfFeCau61X1PioBR5gBD8", // <-- Replace with your API key from Firebase Console
            authDomain: "ailab-9ef87.firebaseapp.com",
            projectId: "ailab-9ef87",
            storageBucket: "ailab-9ef87.appspot.com",
            messagingSenderId: "558122624068",
            appId: "1:558122624068:web:bde003000c6568f5e74811"
        };
        const app = initializeApp(firebaseConfig);

        const auth = getAuth(app);
        const db = getFirestore(app);
        console.log("Firebase App, Auth, and Firestore initialized with new config!");

        let geminiModel;
        try {
            const ai = getAI(app, { backend: new GoogleAIBackend() });
            geminiModel = getGenerativeModel(ai, { model: "gemini-2.0-flash" });
            console.log("Generative Model instance created with model 'gemini-2.0-flash'!");
        } catch (e) {
            console.error("Error initializing AI Model:", e);
            document.getElementById("gemini-api-error-notice").classList.remove('hidden');
            document.getElementById("gemini-api-error-notice").innerHTML = `<p class="font-bold">AI Model initialization error!</p><p>${e.message}. Please check your Firebase project configuration and ensure the Generative Language API is enabled in Google Cloud Console.</p>`;
        }


        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-ai-lab-app';
        let currentUserId = null;
        let currentSelectedAiChemical = null;

        // NEW: Experiment related variables
        let currentExperimentId = null; // ID of the currently loaded/saved experiment
        let currentExperimentData = null; // Data of the currently loaded experiment
        let isExperimentModified = false; // Track if the current experiment in beaker is modified

        const loginFormContainer = document.getElementById('login-form-container');
        const registerFormContainer = document.getElementById('register-form-container');
        const authContainer = document.getElementById('auth-container');
        const labSection = document.getElementById('lab-section');
        const userEmailDisplay = document.getElementById('user-email-display');
        const signOutButton = document.getElementById('signOutButton');
        const loginEmailInput = document.getElementById('loginEmail');
        const loginPasswordInput = document.getElementById('loginPassword');
        const loginButton = document.getElementById('loginButton');
        const registerEmailInput = document.getElementById('registerEmail');
        const registerPasswordInput = document.getElementById('registerPassword');
        const registerButton = document.getElementById('registerButton');
        const showRegisterLink = document.getElementById('showRegisterLink');
        const showLoginLink = document.getElementById('showLoginLink');
        const chemicalNameInput = document.getElementById('chemicalNameInput');
        const createChemicalButton = document.getElementById('createChemicalButton');
        const userChemicalsContainer = document.getElementById('userChemicalsContainer');
        const confirmSaveModal = document.getElementById('confirmSaveModal');
        const confirmChemicalDetails = document.getElementById('confirmChemicalDetails');
        const cancelSaveChemical = document.getElementById('cancelSaveChemical');
        const confirmSaveChemicalButtonAction = document.getElementById('confirmSaveChemicalButtonAction');
        const geminiApiErrorNotice = document.getElementById('gemini-api-error-notice');

        const infoPanel = document.getElementById('info-panel');
        const infoPanelOverlay = document.getElementById('info-panel-overlay');
        const infoPanelTitle = document.getElementById('info-panel-title');
        const infoPanelDescription = document.getElementById('info-panel-description');
        const infoPanelCloseButton = document.getElementById('info-panel-close-button');
        const infoPanelCloseX = document.getElementById('info-panel-close-x');

        // NEW: Chemical Search Input
        const chemicalSearchInput = document.getElementById('chemicalSearchInput');

        // NEW: Experiment DOM elements
        const toggleExperimentManagementButton = document.getElementById('toggleExperimentManagementButton');
        const experimentManagementSection = document.getElementById('experimentManagementSection');
        const toggleExperimentText = document.getElementById('toggleExperimentText');
        const experimentNameInput = document.getElementById('experimentNameInput');
        const saveExperimentButton = document.getElementById('saveExperimentButton');
        const userExperimentsContainer = document.getElementById('userExperimentsContainer');
        const confirmDeleteExperimentModal = document.getElementById('confirmDeleteExperimentModal');
        const confirmDeleteExperimentText = document.getElementById('confirmDeleteExperimentText');
        const experimentToDeleteName = document.getElementById('experimentToDeleteName');
        const cancelDeleteExperiment = document.getElementById('cancelDeleteExperiment');
        const confirmDeleteExperiment = document.getElementById('confirmDeleteExperiment');

        // NEW: Experiment Suggestion DOM elements
        const experimentSuggestionPrompt = document.getElementById('experimentSuggestionPrompt');
        const suggestExperimentButton = document.getElementById('suggestExperimentButton');
        const experimentSuggestionResults = document.getElementById('experimentSuggestionResults');

        // NEW: Safety Alert Display
        const safetyAlertContainer = document.getElementById('safety-alert-container');

        let experimentIdToDelete = null; // To store ID of experiment to delete

        // Stored chemicals for filtering
        let allUserChemicals = [];

        // NEW: Default chemicals data
        const DEFAULT_CHEMICALS_DATA = [
            {
                name: "Nước",
                formula: "H2O",
                smiles: "O",
                appearance: "Chất lỏng trong suốt, không màu.",
                solutionColor: "rgba(173, 216, 230, 0.5)",
                description: "Dung môi phổ biến nhất, cần thiết cho sự sống. Là một oxide lưỡng tính yếu.",
                type: "oxide",
                strength: "neutral",
                stateAtSTP: "liquid",
                isSoluble: true,
                ionFormation: {"cation": "H+", "anion": "OH-"},
                colorWhenDry: "Không màu",
                density_g_cm3: 1,
                boiling_point_C: 100,
                melting_point_C: 0,
                isFlammable: false,
                isReactive: false,
                safetyPrecautions: "An toàn tuyệt đối.",
                specificReactions: []
            },
            {
                name: "Axit Clohydric",
                formula: "HCl",
                smiles: "Cl",
                appearance: "Chất lỏng không màu, bốc khói trong không khí ẩm.",
                solutionColor: "rgba(255, 100, 100, 0.1)", // Light pink
                description: "Là một axit mạnh, ăn mòn nhiều kim loại. Được sử dụng rộng rãi trong công nghiệp và phòng thí nghiệm.",
                type: "acid",
                strength: "strong",
                stateAtSTP: "liquid",
                isSoluble: true,
                ionFormation: {"cation": "H+", "anion": "Cl-"},
                colorWhenDry: "Không màu",
                density_g_cm3: 1.18,
                boiling_point_C: "Khoảng -85 (khan) đến 110 (dung dịch 20.2%)",
                isFlammable: false,
                isReactive: true,
                safetyPrecautions: "Ăn mòn mạnh. Mang găng tay, kính bảo hộ. Tránh hít hơi.",
                specificReactions: [
                    {"with": "NaOH", "phenomenon": "Phản ứng trung hòa, tỏa nhiệt mạnh.", "product": "NaCl, H2O"},
                    {"with": "Zn", "phenomenon": "Sủi bọt khí H2 mạnh.", "product": "ZnCl2, H2"}
                ]
            },
            {
                name: "Natri Hydroxit",
                formula: "NaOH",
                smiles: "[Na+].[OH-]",
                appearance: "Chất rắn màu trắng, hút ẩm mạnh.",
                solutionColor: "rgba(100, 100, 255, 0.1)", // Light blue
                description: "Là một bazơ mạnh, tan nhiều trong nước, tạo dung dịch kiềm ăn mòn. Thường được gọi là xút ăn da.",
                type: "base",
                strength: "strong",
                stateAtSTP: "solid",
                isSoluble: true,
                ionFormation: {"cation": "Na+", "anion": "OH-"},
                colorWhenDry: "Trắng",
                density_g_cm3: 2.13,
                melting_point_C: 318,
                boiling_point_C: 1388,
                isFlammable: false,
                isReactive: true,
                safetyPrecautions: "Ăn mòn da, mắt. Cần thiết bị bảo hộ, rửa sạch ngay khi tiếp xúc.",
                specificReactions: [
                    {"with": "HCl", "phenomenon": "Phản ứng trung hòa, tỏa nhiệt mạnh.", "product": "NaCl, H2O"},
                    {"with": "CuCl2", "phenomenon": "Tạo kết tủa xanh lam Cu(OH)2.", "product": "Cu(OH)2, NaCl"}
                ]
            },
            {
                name: "Đồng(II) Sunfat",
                formula: "CuSO4",
                smiles: "[Cu+2].[O-]S(=O)(=O)[O-]",
                appearance: "Chất rắn tinh thể màu xanh lam.",
                solutionColor: "rgba(0, 0, 255, 0.4)", // Dark blue
                description: "Muối đồng, tan tốt trong nước tạo dung dịch màu xanh. Được dùng làm thuốc diệt nấm, thuốc trừ sâu.",
                type: "salt",
                strength: "neutral",
                stateAtSTP: "solid",
                isSoluble: true,
                ionFormation: {"cation": "Cu2+", "anion": "SO42-"},
                colorWhenDry: "Xanh lam",
                density_g_cm3: 2.286,
                melting_point_C: 150, // decomposes
                isFlammable: false,
                isReactive: false,
                safetyPrecautions: "Độc hại nếu nuốt phải. Tránh tiếp xúc da, mắt.",
                specificReactions: [
                    {"with": "NaOH", "phenomenon": "Tạo kết tủa xanh lam Cu(OH)2.", "product": "Cu(OH)2, Na2SO4"},
                    {"with": "Fe", "phenomenon": "Sắt bị ăn mòn, tạo đồng kim loại màu đỏ nâu.", "product": "FeSO4, Cu"}
                ]
            },
            {
                name: "Bạc Nitrat",
                formula: "AgNO3",
                smiles: "[Ag+].[O-][N+](=O)O",
                appearance: "Chất rắn tinh thể không màu.",
                solutionColor: "rgba(255, 255, 255, 0.1)", // Transparent
                description: "Muối bạc, tan tốt trong nước. Dùng trong nhiếp ảnh, y học. Nhạy cảm với ánh sáng.",
                type: "salt",
                strength: "neutral",
                stateAtSTP: "solid",
                isSoluble: true,
                ionFormation: {"cation": "Ag+", "anion": "NO3-"},
                colorWhenDry: "Không màu",
                density_g_cm3: 4.35,
                melting_point_C: 209,
                isFlammable: false,
                isReactive: true,
                safetyPrecautions: "Gây ăn mòn da, mắt. Để lại vết đen trên da khi tiếp xúc với ánh sáng. Tránh xa ánh sáng.",
                specificReactions: [
                    {"with": "NaCl", "phenomenon": "Tạo kết tủa trắng AgCl.", "product": "AgCl, NaNO3", "reactionDurationSeconds": 1}, // Fast reaction
                    {"with": "Cu", "phenomenon": "Đồng bị ăn mòn, tạo bạc kim loại sáng bóng.", "product": "Cu(NO3)2, Ag"}
                ]
            },
            {
                name: "Natri Carbonat",
                formula: "Na2CO3",
                smiles: "[Na+].[Na+].[O-]C([O-])=O",
                appearance: "Chất rắn bột màu trắng.",
                solutionColor: "rgba(100, 100, 255, 0.1)", // Light blue (weak base)
                description: "Muối natri của axit cacbonic. Dùng trong công nghiệp thủy tinh, xà phòng.",
                type: "salt",
                strength: "weak base",
                stateAtSTP: "solid",
                isSoluble: true,
                ionFormation: {"cation": "Na+", "anion": "CO32-"},
                colorWhenDry: "Trắng",
                density_g_cm3: 2.54,
                melting_point_C: 851,
                isFlammable: false,
                isReactive: false,
                safetyPrecautions: "Gây kích ứng mắt và da. Tránh hít bụi.",
                specificReactions: [
                    {"with": "HCl", "phenomenon": "Sủi bọt khí CO2 mạnh mẽ.", "product": "NaCl, H2O, CO2", "reactionDurationSeconds": 3} // Medium reaction
                ]
            },
            {
                name: "Canxi Clorua",
                formula: "CaCl2",
                smiles: "[Ca+2].[Cl-].[Cl-]",
                appearance: "Chất rắn dạng hạt màu trắng.",
                solutionColor: "rgba(173, 216, 230, 0.1)", // Transparent
                description: "Muối clorua của canxi, hút ẩm mạnh. Dùng làm chất hút ẩm, trong xây dựng.",
                type: "salt",
                strength: "neutral",
                stateAtSTP: "solid",
                isSoluble: true,
                ionFormation: {"cation": "Ca2+", "anion": "Cl-"},
                colorWhenDry: "Trắng",
                density_g_cm3: 2.15,
                melting_point_C: 772,
                isFlammable: false,
                isReactive: false,
                safetyPrecautions: "Gây kích ứng da, mắt. Có thể gây bỏng nếu tiếp xúc với nước.",
                specificReactions: [
                     {"with": "Na2CO3", "phenomenon": "Tạo kết tủa trắng CaCO3.", "product": "CaCO3, NaCl"}
                ]
            },
            {
                name: "Kali Iodua",
                formula: "KI",
                smiles: "[K+].[I-]",
                appearance: "Chất rắn tinh thể màu trắng.",
                solutionColor: "rgba(255, 255, 255, 0.1)", // Transparent
                description: "Muối iodua của kali. Dùng trong y tế, hóa phân tích.",
                type: "salt",
                strength: "neutral",
                stateAtSTP: "solid",
                isSoluble: true,
                ionFormation: {"cation": "K+", "anion": "I-"},
                colorWhenDry: "Trắng",
                density_g_cm3: 3.13,
                melting_point_C: 681,
                isFlammable: false,
                isReactive: false,
                safetyPrecautions: "Có thể gây kích ứng. Tránh nuốt phải.",
                specificReactions: [
                    {"with": "Pb(NO3)2", "phenomenon": "Tạo kết tủa vàng PbI2.", "product": "PbI2, KNO3"}
                ]
            },
            {
                name: "Chì(II) Nitrat",
                formula: "Pb(NO3)2",
                smiles: "[Pb+2].[O-][N+](=O)O.[O-][N+](=O)O",
                appearance: "Chất rắn tinh thể màu trắng.",
                solutionColor: "rgba(255, 255, 255, 0.1)", // Transparent
                description: "Muối nitrat của chì. Độc hại. Dùng trong công nghiệp diêm, thuốc nổ.",
                type: "salt",
                strength: "neutral",
                stateAtSTP: "solid",
                isSoluble: true,
                ionFormation: {"cation": "Pb2+", "anion": "NO3-"},
                colorWhenDry: "Trắng",
                density_g_cm3: 4.53,
                melting_point_C: 290, // decomposes
                isFlammable: false,
                isReactive: false,
                safetyPrecautions: "Rất độc hại. Không được nuốt hoặc hít phải. Cần thiết bị bảo hộ đầy đủ. Gây ô nhiễm môi trường.",
                specificReactions: [
                     {"with": "KI", "phenomenon": "Tạo kết tủa vàng PbI2.", "product": "PbI2, KNO3", "reactionDurationSeconds": 2} // Medium reaction
                ]
            }
        ];

        function showToast(message) {
            const toast = document.getElementById('customToast');
            if (toast) {
                toast.textContent = message;
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            } else {
                console.warn("Custom toast element not found. Message:", message);
            }
        }

        async function callGeminiAPI(promptText) {
            const responseContainer = document.getElementById("responseContainer");

            if (!geminiModel) {
                const errorMessage = "AI model not initialized. Please check console for errors.";
                if (responseContainer) {
                    responseContainer.innerText = errorMessage;
                }
                console.error(errorMessage);
                return;
            }
            if (!promptText || !promptText.trim()) {
                if (typeof showToast === 'function') {
                    showToast("Please enter a prompt for Gemini.");
                }
                return;
            }

            if (responseContainer) {
                responseContainer.textContent = "Sending request to Gemini...";
            }
            console.log("Calling generic Gemini API with prompt:", promptText);

            try {
                // Using the Firebase AI Logic SDK to generate content
                const result = await geminiModel.generateContent(promptText);
                const response = result.response;
                const text = response.text();
                if(responseContainer) {
                    responseContainer.innerHTML = `<strong>AI Response:</strong><br>${text}`;
                }
                console.log("Response text from generic Gemini API:", text);
            } catch (error) {
                console.error("Error calling Gemini API (generic):", error);
                if (responseContainer) {
                    responseContainer.innerHTML = `<span class="text-red-600 font-bold">Gemini Error: ${error.message}.</span>`;
                }
                 // Show API error notice only if it's an actual API error, not a prompt issue.
                geminiApiErrorNotice.classList.remove('hidden');
                geminiApiErrorNotice.innerHTML = `<p class="font-bold">Gemini API connection error!</p><p>${error.message}. Please check your Firebase project configuration and ensure the Generative Language API is enabled in Google Cloud Console.</p>`;
            }
        }

        function displayChemicalInfoInPanel(chemicalData) {
            if (chemicalData && infoPanel && infoPanelTitle && infoPanelDescription && infoPanelOverlay) {
                infoPanelTitle.textContent = chemicalData.name || "Chemical Information";
                infoPanelDescription.innerHTML = `
                    <p><strong>Formula:</strong> ${chemicalData.formula || 'N/A'}</p>
                    <p><strong>SMILES Code:</strong> ${chemicalData.smiles || 'N/A'}</p>
                    <p><strong>Appearance:</strong> ${chemicalData.appearance || 'N/A'}</p>
                    <p><strong>Type:</strong> ${chemicalData.type || 'N/A'}</p>
                    <p><strong>Strength:</strong> ${chemicalData.strength || 'N/A'}</p>
                    <p><strong>Standard State:</strong> ${chemicalData.stateAtSTP || 'N/A'}</p>
                    <p><strong>Solubility in Water:</strong> ${chemicalData.isSoluble !== undefined ? (chemicalData.isSoluble ? 'Soluble' : 'Insoluble') : 'N/A'}</p>
                    <p><strong>Solution Color:</strong> <span style="display:inline-block; width:20px; height:20px; background-color:${chemicalData.solutionColor || 'transparent'}; border: 1px solid #ccc; vertical-align: middle;"></span> ${chemicalData.solutionColor || 'N/A'}</p>
                    <p><strong>Color when dry:</strong> ${chemicalData.colorWhenDry || 'N/A'}</p>
                    ${chemicalData.ionFormation ? `<p><strong>Ion Formation:</strong> Cation: ${chemicalData.ionFormation.cation || 'N/A'}, Anion: ${chemicalData.ionFormation.anion || 'N/A'}</p>` : ''}
                    <p class="mt-3"><strong>Detailed Description:</strong> ${chemicalData.description || "No detailed description available."}</p>
                    ${chemicalData.density_g_cm3 ? `<p><strong>Density:</strong> ${chemicalData.density_g_cm3} g/cm³</p>` : ''}
                    ${chemicalData.boiling_point_C ? `<p><strong>Boiling Point:</strong> ${chemicalData.boiling_point_C} °C</p>` : ''}
                    ${chemicalData.melting_point_C ? `<p><strong>Melting Point:</strong> ${chemicalData.melting_point_C} °C</p>` : ''}
                    ${chemicalData.isFlammable !== undefined ? `<p><strong>Flammable:</strong> ${chemicalData.isFlammable ? 'Yes' : 'No'}</p>` : ''}
                    ${chemicalData.isReactive !== undefined ? `<p><strong>Reactive:</strong> ${chemicalData.isReactive ? 'Yes' : 'No'}</p>` : ''}
                    ${chemicalData.safetyPrecautions ? `<p><strong>Safety Precautions:</strong> <span class="text-red-700 font-semibold">${chemicalData.safetyPrecautions}</span></p>` : ''}
                    ${chemicalData.specificReactions && chemicalData.specificReactions.length > 0 ? `
                        <h4 class="font-semibold mt-3 mb-1">Specific Reactions:</h4>
                        <ul class="list-disc list-inside">
                            ${chemicalData.specificReactions.map(r => `<li>With ${r.with}: ${r.phenomenon} (Product: ${r.product})</li>`).join('')}
                        </ul>
                    ` : ''}
                `;

                // NEW: Logic to draw molecule from SMILES string
                const canvas = document.getElementById('molecule-canvas');
                const smilesNotFound = document.getElementById('smiles-not-found');
                const drawingContainer = document.getElementById('molecule-drawing-container');

                if (chemicalData.smiles && chemicalData.smiles.trim() !== "") {
                    canvas.classList.remove('hidden');
                    smilesNotFound.classList.add('hidden');
                    drawingContainer.classList.remove('hidden');

                    let smilesDrawer = new SmilesDrawer.Drawer({ width: 300, height: 300 });

                    SmilesDrawer.parse(chemicalData.smiles, function(tree) {
                        smilesDrawer.draw(tree, 'molecule-canvas', 'light', false);
                    }, function(err) {
                        console.error("SmilesDrawer Error:", err);
                        canvas.classList.add('hidden');
                        smilesNotFound.textContent = "Error drawing structure from SMILES code.";
                        smilesNotFound.classList.remove('hidden');
                    });
                } else {
                    canvas.classList.add('hidden');
                    smilesNotFound.textContent = "SMILES code not found to draw structure.";
                    smilesNotFound.classList.remove('hidden');
                    drawingContainer.classList.remove('hidden');
                }

                infoPanel.classList.remove('hidden');
                infoPanelOverlay.classList.remove('hidden');
                setTimeout(() => {
                    infoPanel.style.opacity = '1';
                    infoPanel.style.transform = 'translate(-50%, -50%) scale(1)';
                    infoPanelOverlay.style.opacity = '1';
                }, 10);
            } else {
                console.warn("Could not display info panel. Data or panel elements missing.");
            }
        }

        function hideInfoPanel() {
            if (infoPanel && infoPanelOverlay) {
                infoPanel.style.opacity = '0';
                infoPanel.style.transform = 'translate(-50%, -50%) scale(0.95)';
                infoPanelOverlay.style.opacity = '0';
                setTimeout(() => {
                    infoPanel.classList.add('hidden');
                    infoPanelOverlay.classList.add('hidden');
                }, 300);
            }
        }
        if (infoPanelCloseButton) infoPanelCloseButton.addEventListener('click', hideInfoPanel);
        if (infoPanelCloseX) infoPanelCloseX.addEventListener('click', hideInfoPanel);
        if (infoPanelOverlay) infoPanelOverlay.addEventListener('click', hideInfoPanel);


        showRegisterLink.addEventListener('click', (e) => {
            e.preventDefault();
            loginFormContainer.classList.add('hidden');
            registerFormContainer.classList.remove('hidden');
        });

        showLoginLink.addEventListener('click', (e) => {
            e.preventDefault();
            registerFormContainer.classList.add('hidden');
            loginFormContainer.classList.remove('hidden');
        });

        setPersistence(auth, browserLocalPersistence)
            .then(() => {
                console.log("Firebase Auth persistence set to local.");
            })
            .catch((error) => {
                console.error("Error setting auth persistence:", error);
            });

        onAuthStateChanged(auth, (user) => {
            if (user) {
                currentUserId = user.uid;
                console.log("User logged in:", currentUserId, user.email);
                userEmailDisplay.textContent = `Logged in as: ${user.email} (ID: ${currentUserId.substring(0,6)}...)`;
                signOutButton.classList.remove('hidden');
                authContainer.classList.add('lab-hidden');
                labSection.classList.remove('lab-hidden');
                loadUserChemicals();
                loadUserExperiments(); // NEW: Load user's experiments
                initializeLabKonva();
            } else {
                currentUserId = null;
                console.log("User logged out or not logged in.");
                userEmailDisplay.textContent = "Not logged in";
                signOutButton.classList.add('hidden');
                authContainer.classList.remove('lab-hidden');
                labSection.classList.add('lab-hidden');
                clearLabOnLogout();
            }
        });

        loginButton.addEventListener('click', async () => {
            const email = loginEmailInput.value;
            const password = loginPasswordInput.value;
            if (!email || !password) {
                showToast("Please enter email and password.");
                return;
            }
            try {
                await signInWithEmailAndPassword(auth, email, password);
                showToast("Login successful!");
                loginEmailInput.value = '';
                loginPasswordInput.value = '';
            } catch (error) {
                console.error("Login error:", error);
                if (typeof showToast === 'function') {
                    showToast(`Login error: ${error.message}`);
                } else {
                    console.error("showToast is not defined in loginButton catch. Error:", `Login error: ${error.message}`);
                }
            }
        });

        registerButton.addEventListener('click', async () => {
            const email = registerEmailInput.value;
            const password = registerPasswordInput.value;
            if (!email || !password) {
                showToast("Please enter email and password.");
                return;
            }
            if (password.length < 6) {
                showToast("Password must be at least 6 characters.");
                return;
            }
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                showToast("Registration successful! Redirecting to login...");
                registerEmailInput.value = '';
                registerPasswordInput.value = '';
                showLoginLink.click();
            } catch (error) {
                console.error("Registration error:", error);
                if (typeof showToast === 'function') {
                    showToast(`Registration error: ${error.message}. Please ensure Email/Password method is enabled in Firebase Console.`);
                } else {
                    console.error("showToast is not defined in registerButton catch. Error:", `Registration error: ${error.message}`);
                }
            }
        });

        signOutButton.addEventListener('click', async () => {
            try {
                await signOut(auth);
                showToast("Logged out.");
            } catch (error) {
                console.error("Logout error:", error);
                if (typeof showToast === 'function') {
                    showToast(`Logout error: ${error.message}`);
                }
            }
        });

        createChemicalButton.addEventListener('click', async () => {
            if (!currentUserId) {
                showToast("Please log in to create chemicals.");
                return;
            }
            if (!geminiModel) {
                 showToast("AI model is not ready to create chemicals.");
                 document.getElementById("gemini-api-error-notice").classList.remove('hidden'); // Ensure error notice is visible
                 return;
            }

            const chemicalName = chemicalNameInput.value.trim();
            if (!chemicalName) {
                showToast("Please enter a chemical name.");
                return;
            }
            showToast("Contacting AI to define chemical..."); 

            // Show loading state for button
            const originalButtonText = createChemicalButton.innerHTML;
            createChemicalButton.innerHTML = '<svg class="animate-spin h-5 w-5 mr-3 inline-block" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Creating...';
            createChemicalButton.disabled = true;


            geminiApiErrorNotice.classList.add('hidden'); 
            currentSelectedAiChemical = null;

            // UPDATED PROMPT: Added "smiles" field request
            const prompt = `Provide detailed information about the chemical "${chemicalName}" as a single JSON object. The JSON object must include the following fields:
- "name": (string) Full and common name of the chemical.
- "formula": (string) Chemical formula.
- "smiles": (string, optional) SMILES code of the chemical. If not found or not applicable, return an empty string "".
- "appearance": (string) Brief description of the physical form and state at normal conditions (e.g., colorless liquid, white crystalline solid).
- "solutionColor": (string) An RGBA string representing the color of the chemical's solution when dissolved in water (if applicable). Example: "rgba(255, 100, 100, 0.6)" for light pink, or "rgba(255, 255, 255, 0.1)" if colorless/very faint. If it's an insoluble solid, can be "rgba(200,200,200,0.7)".
- "description": (string) More detailed description of basic physical, chemical properties, applications, or safety warnings (if any).
- "type": (string, optional) Type of chemical (e.g., "acid", "base", "salt", "metal", "nonmetal", "oxide", "organic").
- "strength": (string, optional) Strength (e.g., "strong", "weak", "moderate"). Applies to acids, bases.
- "stateAtSTP": (string, optional) Physical state at standard temperature and pressure (STP) (e.g., "liquid", "solid", "gas").
- "isSoluble": (boolean, optional) Solubility in water.
- "ionFormation": (object, optional) Ions formed when dissolved in water, or in pure solid/liquid form. Example: {"cation": "H+", "anion": "Cl-"}.
- "colorWhenDry": (string, optional) Color of the chemical in its pure form (not dissolved in water, pure solid/liquid).
- "density_g_cm3": (number, optional) Density (g/cm³) if available.
- "boiling_point_C": (number or string, optional) Boiling point (°C) if available.
- "melting_point_C": (number or string, optional) Melting point (°C) if available.
- "isFlammable": (boolean, optional) Is it flammable.
- "isReactive": (boolean, optional) Is it reactive.
- "safetyPrecautions": (string, optional) Specific safety warnings or handling instructions (e.g., "Highly corrosive. Wear gloves and eye protection.").
- "specificReactions": (array of objects, optional) An array of characteristic reactions, each object in the form {"with": "other_chemical_name", "phenomenon": "visual_phenomenon_description", "product": "main_product", "reactionDurationSeconds": (number, optional) seconds for reaction, e.g., 1 for fast, 5 for slow, default to 1}. Only include 1-2 most important reactions.

Ensure the output IS ONLY that JSON object, with no other explanatory text around the JSON.
`;
            try {
                const result = await geminiModel.generateContent(prompt);
                const response = result.response;
                let rawJsonText = response.text();

                rawJsonText = rawJsonText.replace(/^```json\s*([\s\S]*?)\s*```$/, '$1').trim();
                console.log("Raw JSON text from AI:", rawJsonText);
                currentSelectedAiChemical = JSON.parse(rawJsonText);
                confirmChemicalDetails.innerHTML = `<pre class="bg-gray-100 p-2 rounded text-xs">${JSON.stringify(currentSelectedAiChemical, null, 2)}</pre>`;
                confirmSaveModal.classList.remove('hidden');
                showToast(`AI has defined the chemical: ${currentSelectedAiChemical.name || chemicalName}. Please confirm to save.`);
            } catch (error) {
                console.error("Error calling Gemini API or parsing JSON:", error);
                showToast(`AI Error: ${error.message}`); 
                geminiApiErrorNotice.classList.remove('hidden');
                geminiApiErrorNotice.innerHTML = `<p class="font-bold">Gemini API connection error!</p><p>${error.message}. Please check your Firebase project configuration and ensure the Generative Language API is enabled in Google Cloud Console.</p>`;
                currentSelectedAiChemical = null;
            } finally {
                // Restore button state
                createChemicalButton.innerHTML = originalButtonText;
                createChemicalButton.disabled = false;
            }
        });

        cancelSaveChemical.addEventListener('click', () => {
            confirmSaveModal.classList.add('hidden');
            currentSelectedAiChemical = null;
            showToast("Chemical save cancelled.");
        });

        confirmSaveChemicalButtonAction.addEventListener('click', async () => {
            if (!currentSelectedAiChemical || !currentUserId) {
                showToast("No chemical info to save or you are not logged in.");
                confirmSaveModal.classList.add('hidden');
                return;
            }
            try {
                const chemicalToSave = {
                    ...currentSelectedAiChemical,
                    userId: currentUserId,
                    createdAt: serverTimestamp()
                };
                const chemicalCollectionRef = collection(db, "artifacts", appId, "users", currentUserId, "customChemicals");
                const docRef = await addDoc(chemicalCollectionRef, chemicalToSave);
                console.log("Chemical saved with ID: ", docRef.id);
                showToast(`Saved chemical: ${currentSelectedAiChemical.name || 'Unnamed'}`);
                chemicalNameInput.value = '';
                currentSelectedAiChemical = null;
                confirmSaveModal.classList.add('hidden');
            } catch (error) {
                console.error("Error saving chemical to Firestore:", error);
                showToast(`Error saving chemical: ${error.message}`);
            }
        });

        let unsubscribeUserChemicals = null;
        let unsubscribeUserExperiments = null;

        async function loadUserChemicals() {
            if (!currentUserId) {
                console.warn("[loadUserChemicals] No currentUserId, skipping load.");
                return;
            }
            console.log(`[loadUserChemicals] Loading chemicals for user: ${currentUserId} and appId: ${appId}`);
            userChemicalsContainer.innerHTML = '<p class="text-gray-500 col-span-full text-center py-4">Loading chemicals...</p>'; 
            if (unsubscribeUserChemicals) {
                unsubscribeUserChemicals();
                console.log("[loadUserChemicals] Unsubscribed from previous chemical listener.");
            }
            const chemicalsRef = collection(db, "artifacts", appId, "users", currentUserId, "customChemicals");
            console.log("[loadUserChemicals] Firestore collection path:", chemicalsRef.path);

            unsubscribeUserChemicals = onSnapshot(chemicalsRef, async (querySnapshot) => {
                allUserChemicals = [];
                querySnapshot.forEach((docSnap) => {
                    allUserChemicals.push({ id: docSnap.id, data: docSnap.data() });
                });

                if (allUserChemicals.length === 0) {
                    console.log("No user chemicals found. Attempting to load default chemicals.");
                    if (!window.defaultChemicalsLoading) {
                        window.defaultChemicalsLoading = true;
                        try {
                            for (const defaultChem of DEFAULT_CHEMICALS_DATA) {
                                await addChemicalIfNotExists(defaultChem, currentUserId);
                            }
                        } finally {
                            window.defaultChemicalsLoading = false;
                        }
                    }
                } else {
                    displayFilteredChemicals();
                }
            }, (error) => {
                console.error(`Error listening to chemical changes for user ${currentUserId}:`, error);
                userChemicalsContainer.innerHTML = '<p class="text-red-500 col-span-full text-center py-4">Error loading chemical list.</p>';
            });
        }
        
        async function addChemicalIfNotExists(chemicalData, userId) {
            const chemicalsRef = collection(db, "artifacts", appId, "users", userId, "customChemicals");
            const q = query(chemicalsRef, where("formula", "==", chemicalData.formula));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                await addDoc(chemicalsRef, { ...chemicalData, userId: userId, createdAt: serverTimestamp() });
                console.log(`Default chemical ${chemicalData.name} added.`);
            } else {
                console.log(`Default chemical ${chemicalData.name} already exists. Skipping.`);
            }
        }

        function displayFilteredChemicals() {
            const searchTerm = chemicalSearchInput.value.toLowerCase();
            userChemicalsContainer.innerHTML = ''; 

            const filteredChemicals = allUserChemicals.filter(chem => {
                const data = chem.data;
                return (data.name && data.name.toLowerCase().includes(searchTerm)) ||
                       (data.formula && data.formula.toLowerCase().includes(searchTerm)) ||
                       (data.type && data.type.toLowerCase().includes(searchTerm));
            });

            if (filteredChemicals.length === 0) {
                userChemicalsContainer.innerHTML = '<p class="text-gray-500 col-span-full text-center py-4">No matching chemicals found.</p>';
                return;
            }

            filteredChemicals.forEach((chem) => {
                const chemicalData = chem.data;
                const chemicalId = chem.id;
                const chemicalElement = document.createElement('div');
                chemicalElement.className = 'chemical-card p-3 bg-white border rounded shadow-sm cursor-pointer hover:shadow-md transition-shadow relative';
                chemicalElement.setAttribute('data-chemical-id', chemicalId);

                let typeColor = 'rgba(100, 100, 100, 1)';
                switch (chemicalData.type) {
                    case 'acid': typeColor = 'rgba(220, 38, 38, 1)'; break;
                    case 'base': typeColor = 'rgba(37, 99, 235, 1)'; break;
                    case 'metal': typeColor = 'rgba(202, 138, 4, 1)'; break;
                    case 'salt': typeColor = 'rgba(22, 163, 74, 1)'; break;
                    case 'oxide': typeColor = 'rgba(124, 58, 237, 1)'; break;
                    case 'organic': typeColor = 'rgba(234, 88, 12, 1)'; break;
                    case 'gas': typeColor = 'rgba(96, 165, 250, 1)'; break;
                    case 'nonmetal': typeColor = 'rgba(75, 85, 99, 1)'; break;
                }

                const typeIndicator = document.createElement('div');
                typeIndicator.className = 'type-indicator';
                typeIndicator.style.backgroundColor = typeColor;
                chemicalElement.appendChild(typeIndicator);

                const bgColor = chemicalData.solutionColor || 'rgba(200,200,200,0.7)';
                chemicalElement.style.backgroundColor = bgColor.replace(/[\d\.]+\)$/g, '0.1)');
                chemicalElement.style.borderColor = typeColor;

                const nameEl = document.createElement('h4');
                nameEl.className = 'font-semibold truncate';
                nameEl.textContent = chemicalData.name || "Unnamed";
                chemicalElement.appendChild(nameEl);
                const formulaEl = document.createElement('p');
                formulaEl.className = 'text-gray-600 truncate';
                formulaEl.textContent = `(${chemicalData.formula || 'N/A'})`;
                chemicalElement.appendChild(formulaEl);

                const tooltip = document.createElement('div');
                tooltip.className = 'chemical-tooltip';
                tooltip.innerHTML = `
                    <strong>${chemicalData.name || 'N/A'}</strong> (${chemicalData.formula || 'N/A'})<br>
                    ${chemicalData.description ? chemicalData.description.substring(0, 100) + (chemicalData.description.length > 100 ? '...' : '') : 'No description.'}
                `;
                chemicalElement.appendChild(tooltip);

                const infoIcon = document.createElement('button');
                infoIcon.innerHTML = `<svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path></svg>`;
                infoIcon.className = 'info-icon-btn';
                infoIcon.title = "View detailed information";
                infoIcon.onclick = (e) => {
                    e.stopPropagation();
                    displayChemicalInfoInPanel(chemicalData);
                };
                chemicalElement.appendChild(infoIcon);

                const deleteButton = document.createElement('button');
                deleteButton.innerHTML = '&times;';
                deleteButton.className = 'absolute top-1 right-1 text-xs bg-red-400 hover:bg-red-600 text-white rounded-full w-4 h-4 flex items-center justify-center focus:outline-none delete-btn';
                deleteButton.title = "Delete this chemical";
                deleteButton.style.lineHeight = '1';
                deleteButton.onclick = async (e) => {
                    e.stopPropagation();
                    const confirmation = confirm(`Are you sure you want to delete chemical "${chemicalData.name || 'this one'}"?`);
                    if (confirmation) {
                        try {
                            await deleteDoc(doc(db, "artifacts", appId, "users", currentUserId, "customChemicals", chemicalId));
                            showToast("Chemical deleted.");
                        } catch (error) {
                            console.error("Error deleting chemical:", error);
                            showToast(`Delete error: ${error.message}`);
                        }
                    }
                };
                chemicalElement.appendChild(deleteButton);

                chemicalElement.addEventListener('click', () => {
                    console.log("Clicked on saved chemical (main area):", chemicalData);
                    addKonvaChemicalFromData(chemicalData, chemicalId);
                });
                userChemicalsContainer.appendChild(chemicalElement);
            });
        }


        chemicalSearchInput.addEventListener('keyup', displayFilteredChemicals);


        async function saveExperiment() {
            if (!currentUserId) {
                showToast("Please log in to save experiments.");
                return;
            }
            const name = experimentNameInput.value.trim();
            if (!name) {
                showToast("Please enter an experiment name.");
                return;
            }
            if (konvaChemicalsInBeaker.length === 0) {
                showToast("The beaker is empty. Please add chemicals before saving.");
                return;
            }

            const originalButtonText = saveExperimentButton.innerHTML;
            saveExperimentButton.innerHTML = '<svg class="animate-spin h-5 w-5 mr-3 inline-block" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Saving...';
            saveExperimentButton.disabled = true;

            try {
                const experimentDataToSave = {
                    name: name,
                    chemicals: konvaChemicalsInBeaker, 
                    userId: currentUserId,
                    createdAt: serverTimestamp()
                };

                const experimentsRef = collection(db, "artifacts", appId, "users", currentUserId, "experiments");
                const q = query(experimentsRef, where("name", "==", name));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    const existingDoc = querySnapshot.docs[0];
                    await setDoc(doc(db, "artifacts", appId, "users", currentUserId, "experiments", existingDoc.id), experimentDataToSave);
                    showToast(`Experiment "${name}" updated!`);
                    currentExperimentId = existingDoc.id;
                } else {
                    const docRef = await addDoc(experimentsRef, experimentDataToSave);
                    showToast(`Experiment "${name}" saved with ID: ${docRef.id}`);
                    currentExperimentId = docRef.id;
                }
                currentExperimentData = experimentDataToSave;
                experimentNameInput.value = '';
                isExperimentModified = false; 
                updateExperimentNameDisplay();
            }
            catch (error) {
                console.error("Error saving experiment:", error);
                showToast(`Error saving experiment: ${error.message}`);
            } finally {
                saveExperimentButton.innerHTML = originalButtonText;
                saveExperimentButton.disabled = false;
            }
        }

        async function loadUserExperiments() {
            if (!currentUserId) {
                console.warn("[loadUserExperiments] No currentUserId, skipping load.");
                return;
            }
            console.log(`[loadUserExperiments] Loading experiments for user: ${currentUserId}`);
            userExperimentsContainer.innerHTML = '<p class="text-gray-500 col-span-full text-center py-4">Loading experiments...</p>';
            if (unsubscribeUserExperiments) {
                unsubscribeUserExperiments();
                console.log("[loadUserExperiments] Unsubscribed from previous experiment listener.");
            }
            const experimentsRef = collection(db, "artifacts", appId, "users", currentUserId, "experiments");

            unsubscribeUserExperiments = onSnapshot(experimentsRef, (querySnapshot) => {
                console.log(`[onSnapshot] Received ${querySnapshot.docs.length} experiment documents.`);
                userExperimentsContainer.innerHTML = '';
                if (querySnapshot.empty) {
                    userExperimentsContainer.innerHTML = '<p class="text-gray-500 col-span-full text-center py-4">You haven\'t saved any experiments yet.</p>';
                    return;
                }
                querySnapshot.forEach((docSnap) => {
                    const experiment = docSnap.data();
                    const experimentId = docSnap.id;
                    const experimentElement = document.createElement('div');
                    experimentElement.className = 'p-3 bg-blue-100 border border-blue-300 rounded shadow-sm flex flex-col justify-between';
                    experimentElement.innerHTML = `
                        <h4 class="font-semibold text-blue-800 text-sm mb-1 truncate">${experiment.name || 'Unnamed experiment'}</h4>
                        <p class="text-xs text-blue-600 mb-2">${experiment.chemicals ? experiment.chemicals.length : 0} chemicals</p>
                        <div class="flex gap-2 text-xs mt-auto">
                            <button class="flex-grow bg-blue-500 hover:bg-blue-600 text-white py-1 px-2 rounded load-experiment-btn" data-experiment-id="${experimentId}">Load</button>
                            <button class="flex-grow bg-red-400 hover:bg-red-500 text-white py-1 px-2 rounded delete-experiment-btn" data-experiment-id="${experimentId}" data-experiment-name="${experiment.name || 'this experiment'}">Delete</button>
                        </div>
                    `;
                    userExperimentsContainer.appendChild(experimentElement);
                });

                userExperimentsContainer.querySelectorAll('.load-experiment-btn').forEach(button => {
                    button.addEventListener('click', async (e) => {
                        const expId = e.target.dataset.experimentId;
                        try {
                            const docRef = doc(db, "artifacts", appId, "users", currentUserId, "experiments", expId);
                            const docSnap = await getDoc(docRef);
                            if (docSnap.exists()) {
                                const expData = docSnap.data();
                                loadExperimentIntoBeaker(expData, expId);
                                showToast(`Experiment "${expData.name}" loaded!`);
                            } else {
                                showToast("Experiment not found.");
                            }
                        } catch (error) {
                            console.error("Error loading experiment:", error);
                            showToast(`Error loading experiment: ${error.message}`);
                        }
                    });
                });

                userExperimentsContainer.querySelectorAll('.delete-experiment-btn').forEach(button => {
                    button.addEventListener('click', (e) => {
                        experimentIdToDelete = e.target.dataset.experimentId;
                        const name = e.target.dataset.experimentName;
                        experimentToDeleteName.textContent = name;
                        confirmDeleteExperimentModal.classList.remove('hidden');
                    });
                });
            }, (error) => {
                console.error(`Error listening to experiment changes for user ${currentUserId}:`, error);
                userExperimentsContainer.innerHTML = '<p class="text-red-500 col-span-full text-center py-4">Error loading experiment list.</p>';
            });
        }

        function loadExperimentIntoBeaker(experimentData, experimentId) {
            currentExperimentId = experimentId;
            currentExperimentData = experimentData;
            experimentNameInput.value = experimentData.name || '';

            konvaChemicalsInBeaker = [];
            stopAllKonvaEffects();
            if(konvaLayer) konvaLayer.find('.dynamic-chemical').forEach(node => node.destroy());

            if (experimentData.chemicals && experimentData.chemicals.length > 0) {
                experimentData.chemicals.forEach(chemical => {
                    konvaChemicalsInBeaker.push(chemical);
                });
                updateKonvaSolutionVisualState(); 
                triggerKonvaReactionAI();
                showToast(`Loaded experiment "${experimentData.name}".`);
            } else {
                updateKonvaSolutionVisualState(); 
                document.getElementById('responseContainer').textContent = "Loaded experiment has no chemicals.";
                showToast(`Experiment "${experimentData.name}" has no chemicals.`);
            }
            isExperimentModified = false;
            updateExperimentNameDisplay();
        }

        async function deleteExperiment(experimentId) {
            if (!currentUserId || !experimentId) return;
            try {
                await deleteDoc(doc(db, "artifacts", appId, "users", currentUserId, "experiments", experimentId));
                showToast("Experiment deleted.");
                if (currentExperimentId === experimentId) { 
                    resetBeaker(); 
                    currentExperimentId = null;
                    currentExperimentData = null;
                    experimentNameInput.value = '';
                }
            } catch (error) {
                console.error("Error deleting experiment:", error);
                showToast(`Delete experiment error: ${error.message}`);
            }
            confirmDeleteExperimentModal.classList.add('hidden');
            experimentIdToDelete = null;
        }

        cancelDeleteExperiment.addEventListener('click', () => {
            confirmDeleteExperimentModal.classList.add('hidden');
            experimentIdToDelete = null;
        });

        confirmDeleteExperiment.addEventListener('click', () => {
            if (experimentIdToDelete) {
                deleteExperiment(experimentIdToDelete);
            }
        });

        function clearLabOnLogout() {
            console.log("[clearLabOnLogout] Clearing lab data.");
            if (unsubscribeUserChemicals) {
                unsubscribeUserChemicals();
                unsubscribeUserChemicals = null;
                console.log("[clearLabOnLogout] Unsubscribed from chemical listener.");
            }
            if (unsubscribeUserExperiments) {
                unsubscribeUserExperiments();
                unsubscribeUserExperiments = null;
                console.log("[clearLabOnLogout] Unsubscribed from experiment listener.");
            }

            if (userChemicalsContainer) {
                userChemicalsContainer.innerHTML = '<p class="text-gray-500 col-span-full text-center py-4">Please log in to view chemicals.</p>';
            }
            if (userExperimentsContainer) {
                userExperimentsContainer.innerHTML = '<p class="text-gray-500 col-span-full text-center py-4">You haven\'t saved any experiments yet.</p>';
            }

            resetBeaker(); 
            currentSelectedAiChemical = null;
            if (geminiApiErrorNotice) { 
                geminiApiErrorNotice.classList.add('hidden');
            }

            currentExperimentId = null;
            currentExperimentData = null;
            experimentNameInput.value = '';
            isExperimentModified = false;
            updateExperimentNameDisplay();
        }

        let konvaStage, konvaLayer, konvaEffectsLayer, konvaToolsLayer;
        let konvaBeaker, konvaSolution;
        let konvaChemicalsInBeaker = [];
        let konvaBubbleAnimation, konvaSmokeAnimation, konvaPrecipitateAnimation, konvaWaveAnimation;
        let konvaWaveLine;
        let konvaExperimentNameText; 
        let konvaThermometer, konvaBurner, konvaTestTube, konvaErlenmeyer;
        let beakerCurrentTemperature = 25; // Default temperature
        let beakerTemperatureDisplay;
        let reactionCountdownInterval = null;

        const KONVA_INITIAL_STAGE_WIDTH = 600;
        const KONVA_INITIAL_STAGE_HEIGHT = 400;
        const KONVA_BEAKER_BASE_SIZE = { width: 150, height: 180 };
        const KONVA_BEAKER_BASE_X = KONVA_INITIAL_STAGE_WIDTH / 2 - (KONVA_BEAKER_BASE_SIZE.width / 2);
        const KONVA_BEAKER_BASE_Y = KONVA_INITIAL_STAGE_HEIGHT - KONVA_BEAKER_BASE_SIZE.height - 20;
        const KONVA_MAX_LIQUID_RISE = KONVA_BEAKER_BASE_SIZE.height * 0.7;
        const KONVA_SOLUTION_PADDING_BASE = 8;
        const BURNER_HEAT_RADIUS_BASE = 100;
        const BURNER_HEAT_INTENSITY = 0.5; // Degrees Celsius per frame when heating

        function initializeLabKonva() {
            console.log("[initializeLabKonva] Initializing Konva stage and objects.");
            if (konvaStage && document.getElementById('konva-stage-container').hasChildNodes()) {
                console.log("[initializeLabKonva] Konva stage already exists, skipping re-initialization.");
                fitKonvaStageToParent();
                return;
            }
            const konvaStageContainer = document.getElementById('konva-stage-container');
            konvaStageContainer.innerHTML = ''; 

            const konvaOuterEl = document.getElementById('konva-outer-container');
            let currentW = Math.min(KONVA_INITIAL_STAGE_WIDTH, konvaOuterEl.clientWidth > 20 ? konvaOuterEl.clientWidth - 20 : KONVA_INITIAL_STAGE_WIDTH);
            let currentH = KONVA_INITIAL_STAGE_HEIGHT;
            konvaStage = new Konva.Stage({
                container: 'konva-stage-container',
                width: currentW,
                height: currentH,
            });
            konvaLayer = new Konva.Layer();
            konvaStage.add(konvaLayer);
            konvaEffectsLayer = new Konva.Layer();
            konvaStage.add(konvaEffectsLayer);
            konvaToolsLayer = new Konva.Layer(); // New layer for tools
            konvaStage.add(konvaToolsLayer);

            konvaBeaker = new Konva.Rect({
                x: getKonvaResponsiveValue(KONVA_BEAKER_BASE_X, KONVA_INITIAL_STAGE_WIDTH, currentW),
                y: getKonvaResponsiveValue(KONVA_BEAKER_BASE_Y, KONVA_INITIAL_STAGE_HEIGHT, currentH), 
                width: getKonvaResponsiveValue(KONVA_BEAKER_BASE_SIZE.width, KONVA_INITIAL_STAGE_WIDTH, currentW),
                height: getKonvaResponsiveValue(KONVA_BEAKER_BASE_SIZE.height, KONVA_INITIAL_STAGE_HEIGHT, currentH), 
                fillLinearGradientStartPoint: { x: 0, y: 0 },
                fillLinearGradientEndPoint: { x: getKonvaResponsiveValue(KONVA_BEAKER_BASE_SIZE.width, KONVA_INITIAL_STAGE_WIDTH, currentW), y: getKonvaResponsiveValue(KONVA_BEAKER_BASE_SIZE.height, KONVA_INITIAL_STAGE_HEIGHT, currentH) },
                fillLinearGradientColorStops: [0, 'rgba(255,255,255,0.7)', 0.5, 'rgba(240,240,240,0.7)', 1, 'rgba(200,200,200,0.7)'],
                stroke: 'black',
                strokeWidth: Math.max(1, getKonvaResponsiveValue(2.5, KONVA_INITIAL_STAGE_WIDTH, currentW)),
                cornerRadius: getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, currentW), 
                shadowColor: 'black',
                shadowBlur: getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, currentW), 
                shadowOffset: { x: getKonvaResponsiveValue(5, KONVA_INITIAL_STAGE_WIDTH, currentW), y: getKonvaResponsiveValue(5, KONVA_INITIAL_STAGE_WIDTH, currentW) },
                shadowOpacity: 0.5, 
                name: 'beaker',
                id: 'beaker-main'
            });
            konvaLayer.add(konvaBeaker);

            konvaSolution = new Konva.Rect({
                fill: 'rgba(173, 216, 230, 0.3)',
                name: 'solution',
                visible: false
            });
            konvaLayer.add(konvaSolution);

            const waveAmplitude = getKonvaResponsiveValue(5, KONVA_INITIAL_STAGE_WIDTH, currentW);
            const waveFrequency = 0.05;

            konvaWaveLine = new Konva.Line({
                stroke: 'white',
                strokeWidth: getKonvaResponsiveValue(2, KONVA_INITIAL_STAGE_WIDTH, currentW),
                lineCap: 'round',
                lineJoin: 'round',
                name: 'waveLine',
                listening: false,
                visible: false
            });
            konvaLayer.add(konvaWaveLine);

            konvaBeaker.moveToTop();

            konvaWaveAnimation = new Konva.Animation(frame => {
                if (!konvaSolution.visible() || konvaSolution.height() === 0 || !konvaWaveLine) {
                    konvaWaveLine.points([]);
                    konvaWaveLine.visible(false);
                    return;
                }
                konvaWaveLine.visible(true);
                const solutionTopY = konvaSolution.y();
                const solutionLeftX = konvaSolution.x();
                const solutionWidth = konvaSolution.width();

                const points = [];
                let currentWaveOffset = (frame.time * 0.008) % (Math.PI * 2);
                for (let i = 0; i <= solutionWidth; i += 5) {
                    const y = solutionTopY + waveAmplitude * Math.sin(i * waveFrequency + currentWaveOffset); 
                    points.push(solutionLeftX + i, y);
                }
                konvaWaveLine.points(points);
                const solutionFillColor = konvaSolution.fill();
                const waveStrokeColor = solutionFillColor.startsWith('rgba') ? solutionFillColor.replace(/[\d\.]+\)$/, '1)') : 'white';
                konvaWaveLine.stroke(waveStrokeColor);
            }, konvaLayer);
            konvaWaveAnimation.start();

            konvaExperimentNameText = new Konva.Text({
                x: getKonvaResponsiveValue(KONVA_INITIAL_STAGE_WIDTH / 2, KONVA_INITIAL_STAGE_WIDTH, currentW),
                y: getKonvaResponsiveValue(20, KONVA_INITIAL_STAGE_HEIGHT, currentH),
                text: 'New Experiment',
                fontSize: getKonvaResponsiveValue(18, KONVA_INITIAL_STAGE_WIDTH, currentW),
                fill: '#374151', 
                align: 'center',
                verticalAlign: 'middle',
            });
            konvaExperimentNameText.offsetX(konvaExperimentNameText.width() / 2);
            konvaLayer.add(konvaExperimentNameText);
            updateExperimentNameDisplay(); 
            
            beakerTemperatureDisplay = document.getElementById('beaker-temperature-display');
            updateBeakerTemperatureDisplay();


            updateKonvaSolutionVisualState();
            window.addEventListener('resize', fitKonvaStageToParent);
            fitKonvaStageToParent();
            console.log("[initializeLabKonva] Konva initialized.");

            konvaBeaker.on('dragenter', function(e) {
                if (e.target.name() === 'dynamic-chemical') {
                    konvaBeaker.stroke('green');
                    konvaBeaker.strokeWidth(Math.max(1, getKonvaResponsiveValue(4, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()))); 
                    konvaBeaker.shadowColor('green');
                    konvaBeaker.shadowBlur(getKonvaResponsiveValue(15, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width())); 
                    konvaBeaker.getLayer().batchDraw();
                }
            });

            konvaBeaker.on('dragleave', function(e) {
                if (e.target.name() === 'dynamic-chemical') {
                    konvaBeaker.stroke('black');
                    konvaBeaker.strokeWidth(Math.max(1, getKonvaResponsiveValue(2.5, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width())));
                    konvaBeaker.shadowColor('black');
                    konvaBeaker.shadowBlur(getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()));
                    konvaBeaker.getLayer().batchDraw();
                }
            });

            initializeLabTools(); // Initialize drag and drop for tools
        }

        function getKonvaResponsiveValue(baseValue, baseStageDim, currentDim) {
            return (baseValue / baseStageDim) * currentDim;
        }
        function getKonvaResponsiveSize(baseDim, baseStageDim, currentDim) { 
            const scale = currentDim / baseStageDim;
            return { width: baseDim * scale, height: baseDim * scale }; 
        }

        function updateBeakerTemperatureDisplay() {
            if (beakerTemperatureDisplay) {
                beakerTemperatureDisplay.textContent = `Nhiệt độ: ${beakerCurrentTemperature.toFixed(1)} °C`;
                beakerTemperatureDisplay.classList.remove('hidden');
            }
        }

        function initializeLabTools() {
            const toolsContainer = document.getElementById('tools-container');
            if (!toolsContainer) return;

            toolsContainer.querySelectorAll('.tool-item').forEach(toolElement => {
                toolElement.addEventListener('mousedown', (e) => {
                    const toolType = toolElement.dataset.toolType;
                    createKonvaTool(toolType, e.clientX, e.clientY);
                });
                toolElement.addEventListener('touchstart', (e) => {
                    const toolType = toolElement.dataset.toolType;
                    createKonvaTool(toolType, e.touches[0].clientX, e.touches[0].clientY);
                });
            });
        }

        function createKonvaTool(toolType, clientX, clientY) {
            if (!konvaStage || !konvaToolsLayer) return;

            const stageRect = konvaStage.container().getBoundingClientRect();
            const startX = clientX - stageRect.left;
            const startY = clientY - stageRect.top;

            let toolGroup;
            const toolBaseSize = 60;
            const scaledToolWidth = getKonvaResponsiveValue(toolBaseSize, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width());
            const scaledToolHeight = getKonvaResponsiveValue(toolBaseSize, KONVA_INITIAL_STAGE_HEIGHT, konvaStage.height());

            if (toolType === 'thermometer') {
                const bulbRadius = scaledToolWidth / 4;
                const stemWidth = scaledToolWidth / 8;
                const stemHeight = scaledToolHeight * 0.8;

                toolGroup = new Konva.Group({
                    x: startX, y: startY, draggable: true, name: 'lab-tool', id: `tool-${Date.now()}`,
                    attrs: { toolType: toolType, heatSource: false } // Default to not a heat source
                });

                const stem = new Konva.Rect({
                    x: -stemWidth / 2, y: -stemHeight, width: stemWidth, height: stemHeight,
                    fill: 'rgba(200,200,200,0.8)', stroke: 'black', strokeWidth: 1, cornerRadius: 2,
                    name: 'stem'
                });
                const mercury = new Konva.Rect({
                    x: -stemWidth / 4, y: -stemHeight + (stemHeight * (1 - (beakerCurrentTemperature / 100))), // Adjust mercury height
                    width: stemWidth / 2, height: stemHeight * (beakerCurrentTemperature / 100), // Adjust mercury height
                    fill: 'red', name: 'mercury'
                });
                const bulb = new Konva.Circle({
                    x: 0, y: 0, radius: bulbRadius, fill: 'red', stroke: 'black', strokeWidth: 1,
                    name: 'bulb'
                });
                const glassBulb = new Konva.Circle({ // Transparent layer over mercury bulb
                    x: 0, y: 0, radius: bulbRadius, fill: 'rgba(255,255,255,0.1)', stroke: 'black', strokeWidth: 1,
                    name: 'glass-bulb'
                });
                
                toolGroup.add(stem);
                toolGroup.add(mercury);
                toolGroup.add(bulb);
                toolGroup.add(glassBulb);
                toolGroup.pivot({ x: 0, y: 0 }); // Set pivot to the bottom of the bulb for easier dragging
                
            } else if (toolType === 'burner') {
                const baseWidth = scaledToolWidth * 1.5;
                const baseHeight = scaledToolHeight * 0.4;
                const flameHeight = scaledToolHeight * 0.6;

                toolGroup = new Konva.Group({
                    x: startX, y: startY, draggable: true, name: 'lab-tool', id: `tool-${Date.now()}`,
                    attrs: { toolType: toolType, heatSource: true, isHeating: false } // This tool is a heat source
                });

                const burnerBase = new Konva.Rect({
                    x: -baseWidth / 2, y: 0, width: baseWidth, height: baseHeight,
                    fill: 'gray', stroke: 'black', strokeWidth: 1, cornerRadius: 5
                });

                const flame = new Konva.RegularPolygon({
                    x: 0, y: -flameHeight, sides: 3, radius: flameHeight / 2,
                    fill: 'orange', rotation: 180, visible: false,
                    id: 'burner-flame'
                });

                toolGroup.add(burnerBase);
                toolGroup.add(flame);

            } else if (toolType === 'test-tube') {
                const tubeWidth = scaledToolWidth * 0.5;
                const tubeHeight = scaledToolHeight * 1.2;

                toolGroup = new Konva.Group({
                    x: startX, y: startY, draggable: true, name: 'lab-tool', id: `tool-${Date.now()}`,
                    attrs: { toolType: toolType, heatSource: false }
                });

                const tube = new Konva.Rect({
                    x: -tubeWidth / 2, y: -tubeHeight, width: tubeWidth, height: tubeHeight,
                    fill: 'rgba(255,255,255,0.7)', stroke: 'black', strokeWidth: 1,
                    cornerRadius: {
                        upperLeft: tubeWidth / 2, upperRight: tubeWidth / 2, lowerLeft: 5, lowerRight: 5
                    }
                });
                toolGroup.add(tube);
            } else if (toolType === 'erlenmeyer') {
                const flaskBaseWidth = scaledToolWidth * 1.5;
                const flaskBodyHeight = scaledToolHeight * 0.7;
                const flaskNeckWidth = scaledToolWidth * 0.4;
                const flaskNeckHeight = scaledToolHeight * 0.3;

                toolGroup = new Konva.Group({
                    x: startX, y: startY, draggable: true, name: 'lab-tool', id: `tool-${Date.now()}`,
                    attrs: { toolType: toolType, heatSource: false }
                });

                const body = new Konva.Line({
                    points: [
                        -flaskBaseWidth / 2, flaskBodyHeight, // Bottom-left
                        flaskBaseWidth / 2, flaskBodyHeight,  // Bottom-right
                        flaskNeckWidth / 2, 0,             // Top-right of body
                        -flaskNeckWidth / 2, 0              // Top-left of body
                    ],
                    fill: 'rgba(255,255,255,0.7)', stroke: 'black', strokeWidth: 1, closed: true
                });

                const neck = new Konva.Rect({
                    x: -flaskNeckWidth / 2, y: -flaskNeckHeight, width: flaskNeckWidth, height: flaskNeckHeight,
                    fill: 'rgba(255,255,255,0.7)', stroke: 'black', strokeWidth: 1, cornerRadius: 2
                });

                toolGroup.add(body);
                toolGroup.add(neck);
                toolGroup.pivot({ x: 0, y: flaskBodyHeight }); // Pivot at the bottom center of the body
            }

            if (toolGroup) {
                konvaToolsLayer.add(toolGroup);
                toolGroup.moveToTop();

                toolGroup.on('dragstart', function() {
                    this.moveToTop();
                    this.scale({x: 1.1, y: 1.1});
                    konvaToolsLayer.batchDraw();
                });

                toolGroup.on('dragend', function() {
                    this.scale({x: 1, y: 1});
                    konvaToolsLayer.batchDraw();
                });

                toolGroup.on('click tap', function(e) {
                    if (this.isDragging() || (this.getStage() && this.getStage().isDragging && this.getStage().isDragging())) {
                        return;
                    }
                    if (this.attrs.toolType === 'burner') {
                        const flame = this.findOne('#burner-flame');
                        const isHeating = !this.attrs.isHeating;
                        this.attrs.isHeating = isHeating;
                        flame.visible(isHeating);
                        showToast(`Burner turned ${isHeating ? 'on' : 'off'}.`);
                    } else if (this.attrs.toolType === 'thermometer') {
                        showToast(`Beaker temperature: ${beakerCurrentTemperature.toFixed(1)} °C`);
                    }
                    konvaToolsLayer.batchDraw();
                });
            }
            konvaToolsLayer.batchDraw();
        }


        function updateKonvaSolutionVisualState() {
            if (!konvaSolution || !konvaBeaker || !konvaStage) {
                console.warn("[updateKonvaSolutionVisualState] Konva elements not fully initialized.");
                return;
            }

            const padding = getKonvaResponsiveValue(KONVA_SOLUTION_PADDING_BASE, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()); 

            konvaSolution.width(konvaBeaker.width() - 2 * padding);
            konvaSolution.x(konvaBeaker.x() + padding);

            if (konvaChemicalsInBeaker.length === 0) {
                konvaSolution.height(0);
                konvaSolution.y(konvaBeaker.y() + konvaBeaker.height() - padding);
                konvaSolution.visible(false);
                if (konvaWaveLine) konvaWaveLine.visible(false); 
            } else {
                const maxRise = getKonvaResponsiveValue(KONVA_MAX_LIQUID_RISE, KONVA_INITIAL_STAGE_HEIGHT, konvaStage.height()); 
                const risePerChemicalDrop = maxRise / (konvaChemicalsInBeaker.length + 5);
                let targetHeight = Math.min(konvaChemicalsInBeaker.length * risePerChemicalDrop, maxRise);

                targetHeight = Math.min(targetHeight, konvaBeaker.height() - 2 * padding);

                konvaSolution.height(targetHeight);
                konvaSolution.y(konvaBeaker.y() + konvaBeaker.height() - targetHeight - padding);
                konvaSolution.visible(true);
                if (konvaWaveLine) konvaWaveLine.visible(true);
            }
            konvaLayer.batchDraw();
        }

        function addKonvaChemicalFromData(chemicalData, firestoreId) {
            if (!konvaStage || !konvaLayer) {
                showToast("Lab is not ready.");
                return;
            }
            console.log(`[addKonvaChemicalFromData] Creating Konva object for: ${chemicalData.name}`);
            const spawnX = getKonvaResponsiveValue(50 + Math.random() * 100, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width());
            const spawnY = getKonvaResponsiveValue(50 + Math.random() * 100, KONVA_INITIAL_STAGE_HEIGHT, konvaStage.height());
            const chemicalSizeBase = 60;
            const scaledChemicalWidth = getKonvaResponsiveValue(chemicalSizeBase, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width());
            const scaledChemicalHeight = getKonvaResponsiveValue(chemicalSizeBase, KONVA_INITIAL_STAGE_HEIGHT, konvaStage.height());


            const group = new Konva.Group({
                x: spawnX, y: spawnY, draggable: true, name: 'dynamic-chemical',
                id: firestoreId, attrs: { chemicalData: chemicalData, initialX: spawnX, initialY: spawnY }
            });

            const bottleBodyWidth = scaledChemicalWidth * 0.7;
            const bottleBodyHeight = scaledChemicalHeight * 0.9;
            const bottleNeckWidth = bottleBodyWidth * 0.4;
            const bottleNeckHeight = scaledChemicalHeight * 0.3;
            const bottleCapHeight = scaledChemicalHeight * 0.15;
            const bottleCapWidth = bottleNeckWidth * 1.5;

            const bottleBody = new Konva.Rect({
                x: (scaledChemicalWidth - bottleBodyWidth) / 2,
                y: bottleCapHeight + bottleNeckHeight,
                width: bottleBodyWidth,
                height: bottleBodyHeight,
                fillLinearGradientStartPoint: { x: 0, y: 0 },
                fillLinearGradientEndPoint: { x: bottleBodyWidth, y: bottleBodyHeight },
                fillLinearGradientColorStops: [0, chemicalData.solutionColor.replace(/[\d\.]+\)$/, '0.6)'), 0.5, chemicalData.solutionColor.replace(/[\d\.]+\)$/, '0.8)'), 1, chemicalData.solutionColor.replace(/[\d\.]+\)$/, '0.6)')],
                stroke: 'black',
                strokeWidth: 1,
                cornerRadius: getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()),
                shadowColor: 'black', shadowBlur: getKonvaResponsiveValue(6,KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()), shadowOpacity: 0.3,
                shadowOffsetX: getKonvaResponsiveValue(3,KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()), shadowOffsetY: getKonvaResponsiveValue(3,KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()),
                name: 'bottle-body'
            });

            const bottleNeck = new Konva.Rect({
                x: (scaledChemicalWidth - bottleNeckWidth) / 2,
                y: bottleCapHeight,
                width: bottleNeckWidth,
                height: bottleNeckHeight,
                fill: bottleBody.fill(),
                stroke: 'black',
                strokeWidth: 1,
                cornerRadius: getKonvaResponsiveValue(3, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()),
                shadowColor: 'black', shadowBlur: getKonvaResponsiveValue(3,KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()), shadowOpacity: 0.2,
                shadowOffsetX: getKonvaResponsiveValue(1,KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()), shadowOffsetY: getKonvaResponsiveValue(1,KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()),
                name: 'bottle-neck'
            });

            const bottleCap = new Konva.Rect({
                x: (scaledChemicalWidth - bottleCapWidth) / 2,
                y: 0,
                width: bottleCapWidth,
                height: bottleCapHeight,
                fill: 'gray',
                stroke: 'black',
                strokeWidth: 1,
                cornerRadius: getKonvaResponsiveValue(3, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()),
                shadowColor: 'black', shadowBlur: getKonvaResponsiveValue(2,KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()), shadowOpacity: 0.2,
                shadowOffsetX: getKonvaResponsiveValue(1,KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()), shadowOffsetY: getKonvaResponsiveValue(1,KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()),
                name: 'bottle-cap'
            });

            group.add(bottleBody);
            group.add(bottleNeck);
            group.add(bottleCap);

            const text = new Konva.Text({
                text: chemicalData.formula || chemicalData.name.substring(0,10),
                fontSize: getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()),
                fill: 'black',
                padding: getKonvaResponsiveValue(5,KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()),
                width: bottleBody.width(),
                height: bottleBody.height(),
                align: 'center',
                verticalAlign: 'middle',
                x: bottleBody.x(),
                y: bottleBody.y() + (bottleBody.height() - getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width())) / 2,
                name: 'bottle-text'
            });
            group.add(text);

            konvaLayer.add(group);
            group.moveToTop();

            group.on('dragstart', function() {
                this.moveToTop(); this.scale({x: 1.1, y: 1.1}); konvaLayer.batchDraw();
            });

            group.on('click tap', function(evt) {
                if (this.isDragging() || (this.getStage() && this.getStage().isDragging && this.getStage().isDragging())) {
                    return;
                }
                const data = this.attrs.chemicalData;
                console.log("[Konva Chemical Click] Displaying info for:", data.name);
                displayChemicalInfoInPanel(data);
            });

            group.on('dragend', function() {
                this.scale({x: 1, y: 1}); 
                const droppedChemicalData = this.attrs.chemicalData;
                const beakerRect = konvaBeaker.getClientRect();
                const chemicalRect = this.getClientRect();

                if (Konva.Util.haveIntersection(beakerRect, chemicalRect)) {
                    showToast(`Added ${droppedChemicalData.name} to beaker.`);

                    const bottleNeckNode = this.findOne('.bottle-neck');
                    const dropStartX = this.x() + bottleNeckNode.x() + bottleNeckNode.width() / 2;
                    const dropStartY = this.y() + bottleNeckNode.y() + bottleNeckNode.height();

                    const dropRadius = getKonvaResponsiveValue(5, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width());
                    const liquidDrop = new Konva.Circle({
                        x: dropStartX,
                        y: dropStartY,
                        radius: dropRadius,
                        fill: chemicalData.solutionColor.replace(/[\d\.]+\)$/, '1)'),
                        opacity: 1,
                        name: 'liquid-drop',
                    });
                    konvaEffectsLayer.add(liquidDrop);

                    new Konva.Tween({
                        node: liquidDrop,
                        duration: 0.5,
                        y: konvaSolution.y() + konvaSolution.height() - dropRadius,
                        easing: Konva.Easings.EaseIn,
                        onFinish: () => {
                            liquidDrop.destroy();
                            konvaEffectsLayer.batchDraw();

                            konvaChemicalsInBeaker.push(droppedChemicalData);
                            console.log("[Konva Drop Animation Finished] Chemicals in beaker:", JSON.stringify(konvaChemicalsInBeaker.map(c => c.name)));
                            updateKonvaSolutionVisualState();
                            triggerKonvaReactionAI();
                            isExperimentModified = true;
                            updateExperimentNameDisplay();
                        }
                    }).play();
                     new Konva.Tween({
                        node: this, 
                        duration: 0.3,
                        x: this.attrs.initialX,
                        y: this.attrs.initialY,
                        easing: Konva.Easings.EaseOut,
                         onFinish: () => {
                            this.opacity(1); 
                            konvaLayer.batchDraw();
                        }
                    }).play();


                } else {
                     new Konva.Tween({
                        node: this,
                        duration: 0.3,
                        x: this.attrs.initialX,
                        y: this.attrs.initialY,
                        easing: Konva.Easings.EaseOut,
                         onFinish: () => {
                            this.opacity(1);
                            konvaLayer.batchDraw();
                        }
                    }).play();
                    showToast("Chemical not dropped into beaker.");
                }
                konvaBeaker.stroke('black');
                konvaBeaker.strokeWidth(Math.max(1, getKonvaResponsiveValue(2.5, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width())));
                konvaBeaker.shadowColor('black');
                konvaBeaker.shadowBlur(getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()));
                konvaLayer.batchDraw();
            });
            konvaLayer.batchDraw();
        }

        async function triggerKonvaReactionAI() {
            if (konvaChemicalsInBeaker.length < 1) {
                stopAllKonvaEffects(); updateKonvaSolutionVisualState();
                document.getElementById('responseContainer').textContent = "Beaker is empty or has only one chemical (not enough for reaction).";
                return;
            }
            if (!geminiModel) {
                 showToast("AI model not ready to analyze reactions.");
                 document.getElementById("gemini-api-error-notice").classList.remove('hidden'); 
                 return;
            }
            stopAllKonvaEffects();
            document.getElementById('reaction-timer').classList.add('hidden'); // Hide timer
            safetyAlertContainer.classList.add('hidden'); // Hide safety alert

            const chemicalNamesInBeaker = konvaChemicalsInBeaker.map(c => c.name).join(', ');
            document.getElementById('responseContainer').textContent = `Analyzing reaction between: ${chemicalNamesInBeaker}...`;
            const originalPromptButtonText = sendPromptButtonLab.innerHTML;
            sendPromptButtonLab.innerHTML = '<svg class="animate-spin h-5 w-5 mr-3 inline-block" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>Sending...';
            sendPromptButtonLab.disabled = true;

            const detailedChemicalsForAI = konvaChemicalsInBeaker.map(chem => ({
                name: chem.name,
                formula: chem.formula,
                type: chem.type,
                strength: chem.strength,
                stateAtSTP: chem.stateAtSTP,
                isSoluble: chem.isSoluble,
                ionFormation: chem.ionFormation,
                solutionColor: chem.solutionColor,
                specificReactions: chem.specificReactions,
                safetyPrecautions: chem.safetyPrecautions
            }));
            
            // Check for heat source
            const isHeating = konvaToolsLayer.find(node => node.name() === 'lab-tool' && node.attrs.toolType === 'burner' && node.attrs.isHeating && Konva.Util.haveIntersection(node.getClientRect(), konvaBeaker.getClientRect())).length > 0;
            const currentTemp = beakerCurrentTemperature;

            const prompt = `Analyze the chemical reaction that might occur when mixing the following chemicals in a beaker, considering current temperature ${currentTemp}°C and whether heat is applied (${isHeating}): ${JSON.stringify(detailedChemicalsForAI, null, 2)}.
Provide the result as a single JSON object, including the following fields:
- "reactionOccurred": (boolean) Does a reaction occur.
- "mainReactionEquation": (string, optional) The main chemical equation of the reaction (if any).
- "products": (array of strings, optional) Names of the main products formed.
- "visualPhenomena": {
    "colorChangeTo": (string, optional) New RGBA color of the solution (e.g., "rgba(100,255,100,0.7)"). If no significant color change, can be omitted or keep mixed color.
    "gasEvolution": (boolean, optional) Are gas bubbles formed.
    "gasEvolutionIntensity": (string, optional) Intensity of gas bubbling (e.g., "low", "medium", "high", "vigorous").
    "precipitateFormation": (boolean, optional) Is a precipitate formed.
    "precipitateColorRGBA": (string, optional) RGBA color code of the precipitate (e.g., "rgba(255, 255, 200, 0.9)").
    "smokeOrVapor": (boolean, optional) Is smoke or vapor emitted.
    "smokeIntensity": (string, optional) Intensity of smoke/vapor (e.g., "low", "medium", "high").
    "temperatureEffect": (string, optional) Description of temperature change (e.g., "exothermic_strong" (strongly exothermic), "endothermic" (endothermic), "negligible" (negligible)).
  }
- "explanation": (string) Detailed explanation of the phenomena, reaction, and results.
- "safetyWarning": (string, optional) Any safety precautions or warnings related to the reaction (e.g., "Strongly exothermic reaction, protective equipment needed.").
- "reactionDurationSeconds": (number, optional) Estimated time in seconds for the reaction to complete (e.g., 1 for instant, 5 for slow). Default to 1 if not specified.
- "conditionsMet": (boolean) Are all necessary conditions (like temperature, catalyst presence, etc.) met for the reaction to occur based on the current lab state?
- "requiredConditions": (string, optional) If conditions are not met, what are the specific conditions required (e.g., "requires high temperature", "requires catalyst X").
Output should be ONLY the JSON object.
`;
            try {
                const result = await geminiModel.generateContent(prompt);
                const response = result.response;
                let rawJsonText = response.text();
                rawJsonText = rawJsonText.replace(/^```json\s*([\s\S]*?)\s*```$/, '$1').trim();
                console.log("AI Reaction Analysis Parsed JSON Text:", rawJsonText);
                const reactionData = JSON.parse(rawJsonText);
                
                document.getElementById('responseContainer').innerHTML = `<strong>AI Explanation:</strong><br>${reactionData.explanation || "No explanation."}<br><strong>Equation (if any):</strong> ${reactionData.mainReactionEquation || "N/A"}<br><strong>Products:</strong> ${reactionData.products ? reactionData.products.join(', ') : "N/A"}`;

                if (reactionData.safetyWarning) {
                    safetyAlertContainer.textContent = `SAFETY ALERT: ${reactionData.safetyWarning}`;
                    safetyAlertContainer.classList.remove('hidden');
                } else {
                    safetyAlertContainer.classList.add('hidden');
                }

                if (reactionData.reactionOccurred && reactionData.conditionsMet) {
                    const phenomena = reactionData.visualPhenomena;
                    if (phenomena.colorChangeTo) {
                        konvaSolution.fill(phenomena.colorChangeTo);
                        konvaLayer.batchDraw();
                    }

                    if (phenomena.gasEvolution) startKonvaBubblingEffect(phenomena.gasEvolutionIntensity);
                    if (phenomena.precipitateFormation) startKonvaPrecipitateEffect(phenomena.precipitateColorRGBA);
                    if (phenomena.smokeOrVapor) startKonvaSmokeEffect(phenomena.smokeIntensity);
                    if (phenomena.temperatureEffect) visualizeTemperatureChange(phenomena.temperatureEffect);

                    // Reaction Timer
                    const duration = reactionData.reactionDurationSeconds || 1;
                    startReactionCountdown(duration);

                } else {
                    stopAllKonvaEffects();
                    if (!reactionData.conditionsMet) {
                        document.getElementById('responseContainer').innerHTML += `<br><span class="text-red-600 font-bold">Conditions not met for reaction!</span><br>Required: ${reactionData.requiredConditions || 'N/A'}`;
                    } else if (!reactionData.reactionOccurred) {
                        document.getElementById('responseContainer').innerHTML += `<br><span class="text-orange-600 font-bold">No significant reaction occurred.</span>`;
                    }
                }
            } catch (error) {
                console.error("Error calling AI for reaction analysis:", error);
                document.getElementById('responseContainer').textContent = `AI Error: ${error.message}`;
                geminiApiErrorNotice.classList.remove('hidden');
                geminiApiErrorNotice.innerHTML = `<p class="font-bold">Gemini API connection error!</p><p>${error.message}. Please check your Firebase project configuration and ensure the Generative Language API is enabled in Google Cloud Console.</p>`;
            } finally {
                sendPromptButtonLab.innerHTML = originalPromptButtonText;
                sendPromptButtonLab.disabled = false;
            }
            konvaLayer.batchDraw();
            konvaEffectsLayer.batchDraw();
        }

        function startReactionCountdown(seconds) {
            const timerDisplay = document.getElementById('reaction-timer');
            timerDisplay.classList.remove('hidden');
            let timeLeft = seconds;
            timerDisplay.textContent = `Reaction completing in: ${timeLeft}s`;

            if (reactionCountdownInterval) clearInterval(reactionCountdownInterval);

            reactionCountdownInterval = setInterval(() => {
                timeLeft--;
                if (timeLeft > 0) {
                    timerDisplay.textContent = `Reaction completing in: ${timeLeft}s`;
                } else {
                    timerDisplay.textContent = `Reaction complete!`;
                    clearInterval(reactionCountdownInterval);
                    reactionCountdownInterval = null;
                    setTimeout(() => timerDisplay.classList.add('hidden'), 2000); // Hide after a short delay
                }
            }, 1000);
        }

        function startKonvaBubblingEffect(intensity = "medium") {
            console.log("[KonvaEffect] Starting Bubbling with intensity:", intensity);
            if (konvaBubbleAnimation) konvaBubbleAnimation.stop();
            if (konvaEffectsLayer) konvaEffectsLayer.find('.bubble').forEach(n => n.destroy());
            let interval = 80;
            let countPerInterval = 1;

            if (intensity === "low") { interval = 150; countPerInterval = 1; }
            else if (intensity === "medium") { interval = 70; countPerInterval = 2; }
            else if (intensity === "high") { interval = 30; countPerInterval = 4; }
            else if (intensity === "vigorous") { interval = 15; countPerInterval = 7; }

            konvaBubbleAnimation = new Konva.Animation(frame => {
                if (!frame || !konvaSolution.visible() || konvaSolution.height() === 0) return;
                if (frame.timeDiff > interval) {
                    for (let i = 0; i < countPerInterval; i++) {
                        const bubble = new Konva.Circle({
                            x: konvaSolution.x() + Math.random() * konvaSolution.width(),
                            y: konvaSolution.y() + konvaSolution.height() - 5,
                            radius: Math.random() * 5 + 3,
                            fill: 'rgba(255, 255, 255, 0.9)', opacity: 1, name: 'bubble'
                        });
                        konvaEffectsLayer.add(bubble);
                        new Konva.Tween({
                            node: bubble,
                            duration: Math.random() * 2 + 1.5,
                            y: konvaSolution.y() - 20,
                            opacity: 0,
                            onFinish: () => bubble.destroy()
                        }).play();
                    }
                }
            }, konvaEffectsLayer);
            konvaBubbleAnimation.start();
        }

        function startKonvaSmokeEffect(intensity = "medium") {
            console.log("[KonvaEffect] Starting Smoke with intensity:", intensity);
            if (konvaSmokeAnimation) konvaSmokeAnimation.stop();
            if (konvaEffectsLayer) konvaEffectsLayer.find('.smoke').forEach(n => n.destroy());
            let interval = 120;
            let countPerInterval = 1;

            if (intensity === "low") { interval = 220; countPerInterval = 1; }
            else if (intensity === "medium") { interval = 100; countPerInterval = 2; }
            else if (intensity === "high") { interval = 50; countPerInterval = 3; }

            konvaSmokeAnimation = new Konva.Animation(frame => {
                if (!frame) return;
                if (frame.timeDiff > interval) {
                    for (let i = 0; i < countPerInterval; i++) {
                        const smoke = new Konva.Ellipse({
                            x: konvaBeaker.x() + konvaBeaker.width() / 2 + (Math.random() - 0.5) * konvaBeaker.width() * 0.8,
                            y: konvaBeaker.y() - 15,
                            radiusX: Math.random() * 15 + 10,
                            radiusY: Math.random() * 10 + 7,
                            fill: 'rgba(180,180,180,0.5)', opacity: 0.7, name: 'smoke'
                        });
                        konvaEffectsLayer.add(smoke);
                        new Konva.Tween({
                            node: smoke,
                            duration: Math.random() * 3.5 + 2.5,
                            y: konvaBeaker.y() - 100, 
                            opacity: 0,
                            scaleX: 2.5,
                            scaleY: 2.5,
                            onFinish: () => smoke.destroy()
                        }).play();
                    }
                }
            }, konvaEffectsLayer);
            konvaSmokeAnimation.start();
        }

        function startKonvaPrecipitateEffect(precipitateColorRGBA = "rgba(250, 250, 250, 0.9)") {
            console.log("[KonvaEffect] Starting Precipitate, color:", precipitateColorRGBA);
            if (konvaPrecipitateAnimation) konvaPrecipitateAnimation.stop();
            if (konvaEffectsLayer) konvaEffectsLayer.find('.precipitate').forEach(n => n.destroy());

            konvaPrecipitateAnimation = new Konva.Animation(frame => {
                 if (!frame || !konvaSolution.visible() || konvaSolution.height() === 0) return;
                if (frame.timeDiff > 30 && Math.random() < 0.6) {
                    const particle = new Konva.Circle({
                        x: konvaSolution.x() + Math.random() * konvaSolution.width(),
                        y: konvaSolution.y() + Math.random() * konvaSolution.height() * 0.7,
                        radius: Math.random() * 4 + 2, 
                        fill: precipitateColorRGBA,
                        opacity: 1, 
                        name: 'precipitate'
                    });
                    konvaEffectsLayer.add(particle);
                    new Konva.Tween({
                        node: particle,
                        duration: Math.random() * 3 + 2,
                        y: konvaSolution.y() + konvaSolution.height() - particle.radius() - 3,
                        easing: Konva.Easings.EaseIn
                    }).play();
                }
            }, konvaEffectsLayer);
            konvaPrecipitateAnimation.start();
        }

        function visualizeTemperatureChange(effectType) {
            console.log("[KonvaEffect] Visualizing Temperature Change:", effectType);
            if (konvaEffectsLayer) konvaEffectsLayer.find('.temp-indicator').forEach(n => n.destroy());

            let color = 'transparent';
            let opacity = 0;
            let duration = 0;

            if (effectType.includes("exothermic")) {
                color = 'rgba(255, 69, 0, 0.8)';
                opacity = 1; 
                duration = 2;
                beakerCurrentTemperature += 20 + Math.random() * 10; // Increase temp
            } else if (effectType.includes("endothermic")) {
                color = 'rgba(0, 191, 255, 0.8)';
                opacity = 1;
                duration = 2;
                beakerCurrentTemperature -= 10 + Math.random() * 5; // Decrease temp
            } else {
                return;
            }
            updateBeakerTemperatureDisplay();

            const tempIndicator = new Konva.Rect({
                x: konvaBeaker.x(),
                y: konvaBeaker.y(),
                width: konvaBeaker.width(),
                height: konvaBeaker.height(),
                fill: color,
                opacity: 0,
                cornerRadius: konvaBeaker.cornerRadius(),
                name: 'temp-indicator'
            });
            konvaEffectsLayer.add(tempIndicator);

            new Konva.Tween({
                node: tempIndicator,
                duration: 0.5,
                opacity: opacity,
                easing: Konva.Easings.EaseIn,
                onFinish: () => {
                    new Konva.Tween({
                        node: tempIndicator,
                        duration: duration,
                        opacity: 0,
                        easing: Konva.Easings.EaseOut,
                        onFinish: () => tempIndicator.destroy()
                    }).play();
                }
            }).play();
            if (konvaEffectsLayer) konvaEffectsLayer.batchDraw();
        }

        // Animation for heating effect
        let heatingAnimation = new Konva.Animation(frame => {
            if (!konvaBeaker) return;

            const beakerCenter = {
                x: konvaBeaker.x() + konvaBeaker.width() / 2,
                y: konvaBeaker.y() + konvaBeaker.height() / 2
            };
            const heatRadius = getKonvaResponsiveValue(BURNER_HEAT_RADIUS_BASE, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width());

            let isBeakerHeated = false;
            konvaToolsLayer.find('.lab-tool').forEach(tool => {
                if (tool.attrs.toolType === 'burner' && tool.attrs.isHeating) {
                    const toolCenter = tool.getClientRect();
                    const distance = Math.sqrt(
                        Math.pow(beakerCenter.x - toolCenter.x, 2) +
                        Math.pow(beakerCenter.y - toolCenter.y, 2)
                    );

                    if (distance < heatRadius) {
                        isBeakerHeated = true;
                    }
                }
            });

            if (isBeakerHeated) {
                beakerCurrentTemperature += BURNER_HEAT_INTENSITY * (frame.timeDiff / 1000); // Increase temperature per second
                if (beakerCurrentTemperature > 100) beakerCurrentTemperature = 100; // Cap at 100 for visual purposes
            } else {
                beakerCurrentTemperature -= BURNER_HEAT_INTENSITY * 0.5 * (frame.timeDiff / 1000); // Cool down slowly
                if (beakerCurrentTemperature < 25) beakerCurrentTemperature = 25; // Floor at 25
            }
            updateBeakerTemperatureDisplay();

            // Update thermometer mercury visually
            konvaToolsLayer.find('.lab-tool[data-tool-type="thermometer"]').forEach(thermometerGroup => {
                const mercury = thermometerGroup.findOne('.mercury');
                const stem = thermometerGroup.findOne('.stem');
                if (mercury && stem) {
                    const maxMercuryHeight = stem.height();
                    const newMercuryHeight = maxMercuryHeight * (beakerCurrentTemperature / 100);
                    mercury.height(newMercuryHeight);
                    mercury.y(stem.y() + stem.height() - newMercuryHeight);
                }
            });

            konvaToolsLayer.batchDraw();
        }, konvaToolsLayer);
        heatingAnimation.start();


        function stopAllKonvaEffects() {
            console.log("[KonvaEffect] Stopping all effects");
            if (konvaBubbleAnimation) { konvaBubbleAnimation.stop(); konvaBubbleAnimation = null; }
            if (konvaSmokeAnimation) { konvaSmokeAnimation.stop(); konvaSmokeAnimation = null; }
            if (konvaPrecipitateAnimation) { konvaPrecipitateAnimation.stop(); konvaPrecipitateAnimation = null; }
            if (reactionCountdownInterval) { clearInterval(reactionCountdownInterval); reactionCountdownInterval = null; }
            document.getElementById('reaction-timer').classList.add('hidden');
            safetyAlertContainer.classList.add('hidden');

            if (konvaEffectsLayer) {
                konvaEffectsLayer.find('.bubble, .smoke, .precipitate, .temp-indicator, .liquid-drop').forEach(n => n.destroy());
                konvaEffectsLayer.batchDraw();
            }

            if (konvaWaveLine) {
                konvaWaveLine.points([]);
                konvaWaveLine.visible(false);
            }
            // Restart wave animation if it was stopped by stopAllKonvaEffects, as it's a persistent visual
            if (konvaSolution && konvaSolution.visible() && konvaSolution.height() > 0 && konvaLayer && !konvaWaveAnimation) {
                 const currentW = konvaStage.width();
                 const waveAmplitude = getKonvaResponsiveValue(5, KONVA_INITIAL_STAGE_WIDTH, currentW);
                 konvaWaveAnimation = new Konva.Animation(frame => {
                    if (!konvaSolution.visible() || konvaSolution.height() === 0 || !konvaWaveLine) {
                        konvaWaveLine.points([]);
                        konvaWaveLine.visible(false);
                        return;
                    }
                    konvaWaveLine.visible(true);
                    const solutionTopY = konvaSolution.y();
                    const solutionLeftX = konvaSolution.x();
                    const solutionWidth = konvaSolution.width();
                    const points = [];
                    let currentWaveOffset = (frame.time * 0.008) % (Math.PI * 2);
                    for (let i = 0; i <= solutionWidth; i += 5) {
                        const y = solutionTopY + waveAmplitude * Math.sin(i * 0.05 + currentWaveOffset); 
                        points.push(solutionLeftX + i, y);
                    }
                    konvaWaveLine.points(points);
                    const solutionFillColor = konvaSolution.fill();
                    const waveStrokeColor = solutionFillColor.startsWith('rgba') ? solutionFillColor.replace(/[\d\.]+\)$/, '1)') : 'white';
                    konvaWaveLine.stroke(waveStrokeColor);
                }, konvaLayer);
                konvaWaveAnimation.start();
            }
        }

        function resetBeaker() {
            konvaChemicalsInBeaker = [];
            stopAllKonvaEffects();

            if (konvaLayer) {
                konvaLayer.find('.dynamic-chemical').forEach(node => {
                    node.destroy();
                });
                konvaLayer.batchDraw();
            }

            if (konvaSolution && konvaBeaker) {
                konvaSolution.height(0);
                konvaSolution.y(konvaBeaker.y() + konvaBeaker.height() - getKonvaResponsiveValue(KONVA_SOLUTION_PADDING_BASE, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()));
                konvaSolution.visible(false);
                konvaSolution.fill('rgba(173, 216, 230, 0.3)');
            }
            if (konvaLayer) konvaLayer.batchDraw();
            document.getElementById('responseContainer').textContent = "Beaker has been cleaned.";
            showToast("Beaker has been cleaned.");

            currentExperimentId = null;
            currentExperimentData = null;
            experimentNameInput.value = '';
            isExperimentModified = false;
            updateExperimentNameDisplay();
            beakerCurrentTemperature = 25; // Reset temperature
            updateBeakerTemperatureDisplay();
        }

        document.getElementById('resetBeakerButton').addEventListener('click', resetBeaker);

        document.getElementById('sendPromptButtonLab').addEventListener('click', () => {
            const promptText = document.getElementById('promptInput').value;
            callGeminiAPI(promptText);
        });

        saveExperimentButton.addEventListener('click', saveExperiment);

        toggleExperimentManagementButton.addEventListener('click', () => {
            const isHidden = experimentManagementSection.classList.toggle('hidden');
            toggleExperimentText.textContent = isHidden ? 'Open Experiment Management' : 'Close Experiment Management';
            if (!isHidden) {
                loadUserExperiments();
            }
        });

        function updateExperimentNameDisplay() {
            if (konvaExperimentNameText && konvaStage) {
                let name = currentExperimentData ? currentExperimentData.name : 'New Experiment';
                konvaExperimentNameText.text(`Experiment Name: ${name}${isExperimentModified ? ' *' : ''}`);
                konvaExperimentNameText.x(getKonvaResponsiveValue(KONVA_INITIAL_STAGE_WIDTH / 2, KONVA_INITIAL_STAGE_WIDTH, konvaStage.width()));
                konvaExperimentNameText.offsetX(konvaExperimentNameText.width() / 2);
                if (konvaLayer) konvaLayer.batchDraw();
            }
        }

        suggestExperimentButton.addEventListener('click', async () => {
            if (!geminiModel) {
                showToast("AI model not ready to suggest experiments.");
                return;
            }
            const prompt = experimentSuggestionPrompt.value.trim();
            if (!prompt) {
                showToast("Please enter a topic or desired outcome for the experiment suggestion.");
                return;
            }
            experimentSuggestionResults.innerHTML = '<p class="text-blue-500">Generating suggestions...</p>';
            suggestExperimentButton.disabled = true;

            const suggestionPrompt = `Suggest a simple chemical experiment based on the following theme/desired outcome: "${prompt}".
            Provide the suggestion as a JSON object with the following fields:
            - "title": (string) A concise title for the experiment.
            - "description": (string) A brief description of the experiment.
            - "requiredChemicals": (array of strings) Names of 2-3 key chemicals needed.
            - "expectedPhenomena": (string) What visual phenomena to expect (e.g., "color change", "gas evolution", "precipitate formation", "heat release").
            - "safetyNotes": (string) Important safety notes.
            - "steps": (array of strings) 3-5 simple steps to perform the experiment.
            Return only the JSON object. Example:
            {
                "title": "Making a precipitate",
                "description": "Observe the formation of a solid precipitate from two clear solutions.",
                "requiredChemicals": ["Lead(II) nitrate", "Potassium iodide"],
                "expectedPhenomena": "Formation of a bright yellow precipitate.",
                "safetyNotes": "Lead compounds are toxic. Handle with care.",
                "steps": [
                    "Dissolve Lead(II) nitrate in water.",
                    "Dissolve Potassium iodide in water.",
                    "Carefully mix the two solutions in a beaker."
                ]
            }`;

            try {
                const result = await geminiModel.generateContent(suggestionPrompt);
                const response = result.response;
                let rawJsonText = response.text();
                rawJsonText = rawJsonText.replace(/^```json\s*([\s\S]*?)\s*```$/, '$1').trim();
                const suggestion = JSON.parse(rawJsonText);

                experimentSuggestionResults.innerHTML = `
                    <h5 class="font-bold text-gray-800 mt-2">${suggestion.title}</h5>
                    <p>${suggestion.description}</p>
                    <p class="text-xs mt-1"><strong>Required Chemicals:</strong> ${suggestion.requiredChemicals.join(', ')}</p>
                    <p class="text-xs"><strong>Expected Phenomena:</strong> ${suggestion.expectedPhenomena}</p>
                    <p class="text-xs text-red-600"><strong>Safety Notes:</strong> ${suggestion.safetyNotes}</p>
                    <p class="text-xs mt-1 font-semibold">Steps:</p>
                    <ol class="list-decimal list-inside text-xs">
                        ${suggestion.steps.map(step => `<li>${step}</li>`).join('')}
                    </ol>
                `;
            } catch (error) {
                console.error("Error suggesting experiment:", error);
                experimentSuggestionResults.innerHTML = `<p class="text-red-500">Error generating suggestion: ${error.message}</p>`;
            } finally {
                suggestExperimentButton.disabled = false;
            }
        });


        function fitKonvaStageToParent() {
            const container = document.getElementById('konva-outer-container');
            if (!container || !konvaStage) return;

            let containerWidth = container.offsetWidth - 16;
            if (containerWidth <= 0) containerWidth = KONVA_INITIAL_STAGE_WIDTH;

            const scale = containerWidth / KONVA_INITIAL_STAGE_WIDTH;
            konvaStage.width(containerWidth);
            konvaStage.height(KONVA_INITIAL_STAGE_HEIGHT * scale);

            const currentW = konvaStage.width();
            const currentH = konvaStage.height();

            if (konvaBeaker) {
                konvaBeaker.x(getKonvaResponsiveValue(KONVA_BEAKER_BASE_X, KONVA_INITIAL_STAGE_WIDTH, currentW));
                konvaBeaker.y(getKonvaResponsiveValue(KONVA_BEAKER_BASE_Y, KONVA_INITIAL_STAGE_HEIGHT, currentH));
                konvaBeaker.width(getKonvaResponsiveValue(KONVA_BEAKER_BASE_SIZE.width, KONVA_INITIAL_STAGE_WIDTH, currentW));
                konvaBeaker.height(getKonvaResponsiveValue(KONVA_BEAKER_BASE_SIZE.height, KONVA_INITIAL_STAGE_HEIGHT, currentH));

                konvaBeaker.strokeWidth(Math.max(1, getKonvaResponsiveValue(2.5, KONVA_INITIAL_STAGE_WIDTH, currentW)));
                konvaBeaker.cornerRadius(getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, currentW));
                konvaBeaker.shadowBlur(getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, currentW));
                konvaBeaker.shadowOffset({
                    x: getKonvaResponsiveValue(5, KONVA_INITIAL_STAGE_WIDTH, currentW),
                    y: getKonvaResponsiveValue(5, KONVA_INITIAL_STAGE_WIDTH, currentW)
                });
                konvaBeaker.fillLinearGradientEndPoint({
                    x: konvaBeaker.width(),
                    y: konvaBeaker.height()
                });
            }
            if (konvaSolution) {
                updateKonvaSolutionVisualState();
            }

            if (konvaWaveLine) {
                konvaWaveLine.strokeWidth(getKonvaResponsiveValue(2, KONVA_INITIAL_STAGE_WIDTH, currentW));
                const waveAmplitude = getKonvaResponsiveValue(5, KONVA_INITIAL_STAGE_WIDTH, currentW);
                if (konvaWaveAnimation) konvaWaveAnimation.stop();
                konvaWaveAnimation = new Konva.Animation(frame => {
                    if (!konvaSolution.visible() || konvaSolution.height() === 0 || !konvaWaveLine) {
                        konvaWaveLine.points([]);
                        konvaWaveLine.visible(false);
                        return;
                    }
                    konvaWaveLine.visible(true);
                    const solutionTopY = konvaSolution.y();
                    const solutionLeftX = konvaSolution.x();
                    const solutionWidth = konvaSolution.width();
                    const points = [];
                    let currentWaveOffset = (frame.time * 0.008) % (Math.PI * 2);
                    for (let i = 0; i <= solutionWidth; i += 5) {
                        const y = solutionTopY + waveAmplitude * Math.sin(i * 0.05 + currentWaveOffset); 
                        points.push(solutionLeftX + i, y);
                    }
                    konvaWaveLine.points(points);
                    const solutionFillColor = konvaSolution.fill();
                    const waveStrokeColor = solutionFillColor.startsWith('rgba') ? solutionFillColor.replace(/[\d\.]+\)$/, '1)') : 'white';
                    konvaWaveLine.stroke(waveStrokeColor);
                }, konvaLayer);
                konvaWaveAnimation.start();
            }

            if (konvaExperimentNameText) {
                konvaExperimentNameText.x(getKonvaResponsiveValue(KONVA_INITIAL_STAGE_WIDTH / 2, KONVA_INITIAL_STAGE_WIDTH, currentW));
                konvaExperimentNameText.y(getKonvaResponsiveValue(20, KONVA_INITIAL_STAGE_HEIGHT, currentH));
                konvaExperimentNameText.fontSize(getKonvaResponsiveValue(18, KONVA_INITIAL_STAGE_WIDTH, currentW));
                konvaExperimentNameText.offsetX(konvaExperimentNameText.width() / 2);
            }

            if (konvaLayer) {
                konvaLayer.find('.dynamic-chemical').forEach(group => {
                    const chemicalSizeBase = 60;
                    const scaledChemicalWidth = getKonvaResponsiveValue(chemicalSizeBase, KONVA_INITIAL_STAGE_WIDTH, currentW);
                    const scaledChemicalHeight = getKonvaResponsiveValue(chemicalSizeBase, KONVA_INITIAL_STAGE_HEIGHT, currentH);

                    const bottleBodyWidth = scaledChemicalWidth * 0.7;
                    const bottleBodyHeight = scaledChemicalHeight * 0.9;
                    const bottleNeckWidth = bottleBodyWidth * 0.4;
                    const bottleNeckHeight = scaledChemicalHeight * 0.3;
                    const bottleCapHeight = scaledChemicalHeight * 0.15;
                    const bottleCapWidth = bottleNeckWidth * 1.5;

                    const bottleBodyNode = group.findOne('.bottle-body');
                    if (bottleBodyNode) {
                        bottleBodyNode.width(bottleBodyWidth).height(bottleBodyHeight)
                            .x((scaledChemicalWidth - bottleBodyWidth) / 2)
                            .y(bottleCapHeight + bottleNeckHeight)
                            .cornerRadius(getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, currentW))
                            .shadowBlur(getKonvaResponsiveValue(6, KONVA_INITIAL_STAGE_WIDTH, currentW))
                            .shadowOffset({x: getKonvaResponsiveValue(3, KONVA_INITIAL_STAGE_WIDTH, currentW), y: getKonvaResponsiveValue(3, KONVA_INITIAL_STAGE_WIDTH, currentW)});
                        bottleBodyNode.fillLinearGradientEndPoint({x: bottleBodyWidth, y: bottleBodyHeight});
                    }

                    const bottleNeckNode = group.findOne('.bottle-neck');
                    if (bottleNeckNode) {
                        bottleNeckNode.width(bottleNeckWidth).height(bottleNeckHeight)
                            .x((scaledChemicalWidth - bottleNeckWidth) / 2)
                            .y(bottleCapHeight)
                            .cornerRadius(getKonvaResponsiveValue(3, KONVA_INITIAL_STAGE_WIDTH, currentW))
                            .shadowBlur(getKonvaResponsiveValue(3, KONVA_INITIAL_STAGE_WIDTH, currentW))
                            .shadowOffset({x: getKonvaResponsiveValue(1, KONVA_INITIAL_STAGE_WIDTH, currentW), y: getKonvaResponsiveValue(1, KONVA_INITIAL_STAGE_WIDTH, currentW)});
                    }

                    const bottleCapNode = group.findOne('.bottle-cap');
                    if (bottleCapNode) {
                        bottleCapNode.width(bottleCapWidth).height(bottleCapHeight)
                            .x((scaledChemicalWidth - bottleCapWidth) / 2)
                            .y(0)
                            .cornerRadius(getKonvaResponsiveValue(3, KONVA_INITIAL_STAGE_WIDTH, currentW))
                            .shadowBlur(getKonvaResponsiveValue(2, KONVA_INITIAL_STAGE_WIDTH, currentW))
                            .shadowOffset({x: getKonvaResponsiveValue(1, KONVA_INITIAL_STAGE_WIDTH, currentW), y: getKonvaResponsiveValue(1, KONVA_INITIAL_STAGE_WIDTH, currentW)});
                    }

                    const textNode = group.findOne('Text.bottle-text');
                    if (textNode && bottleBodyNode) {
                        textNode.fontSize(getKonvaResponsiveValue(10, KONVA_INITIAL_STAGE_WIDTH, currentW))
                                .width(bottleBodyWidth) 
                                .height(bottleBodyHeight)
                                .x(bottleBodyNode.x())
                                .y(bottleBodyNode.y() + (bottleBodyHeight - textNode.fontSize()) / 2);
                    }
                });
            }

            // Resize tools on the Konva layer
            konvaToolsLayer.find('.lab-tool').forEach(toolGroup => {
                const toolType = toolGroup.attrs.toolType;
                const toolBaseSize = 60;
                const scaledToolWidth = getKonvaResponsiveValue(toolBaseSize, KONVA_INITIAL_STAGE_WIDTH, currentW);
                const scaledToolHeight = getKonvaResponsiveValue(toolBaseSize, KONVA_INITIAL_STAGE_HEIGHT, currentH);

                if (toolType === 'thermometer') {
                    const bulbRadius = scaledToolWidth / 4;
                    const stemWidth = scaledToolWidth / 8;
                    const stemHeight = scaledToolHeight * 0.8;

                    const stem = toolGroup.findOne('.stem');
                    const mercury = toolGroup.findOne('.mercury');
                    const bulb = toolGroup.findOne('.bulb');
                    const glassBulb = toolGroup.findOne('.glass-bulb');

                    if (stem) {
                        stem.width(stemWidth);
                        stem.height(stemHeight);
                        stem.x(-stemWidth / 2);
                        stem.y(-stemHeight);
                    }
                    if (mercury) {
                        mercury.width(stemWidth / 2);
                        mercury.x(-stemWidth / 4);
                        // Mercury height will be updated by heatingAnimation
                    }
                    if (bulb) {
                        bulb.radius(bulbRadius);
                        bulb.x(0);
                        bulb.y(0);
                    }
                    if (glassBulb) {
                        glassBulb.radius(bulbRadius);
                        glassBulb.x(0);
                        glassBulb.y(0);
                    }
                } else if (toolType === 'burner') {
                    const baseWidth = scaledToolWidth * 1.5;
                    const baseHeight = scaledToolHeight * 0.4;
                    const flameHeight = scaledToolHeight * 0.6;

                    const burnerBase = toolGroup.findOne('Rect'); // Assuming burner base is the first Rect
                    const flame = toolGroup.findOne('RegularPolygon'); // Assuming flame is a RegularPolygon

                    if (burnerBase) {
                        burnerBase.width(baseWidth);
                        burnerBase.height(baseHeight);
                        burnerBase.x(-baseWidth / 2);
                        burnerBase.y(0);
                    }
                    if (flame) {
                        flame.radius(flameHeight / 2);
                        flame.y(-flameHeight);
                    }
                } else if (toolType === 'test-tube') {
                    const tubeWidth = scaledToolWidth * 0.5;
                    const tubeHeight = scaledToolHeight * 1.2;

                    const tube = toolGroup.findOne('Rect');
                    if (tube) {
                        tube.width(tubeWidth);
                        tube.height(tubeHeight);
                        tube.x(-tubeWidth / 2);
                        tube.y(-tubeHeight);
                        tube.cornerRadius({
                            upperLeft: tubeWidth / 2, upperRight: tubeWidth / 2, lowerLeft: 5, lowerRight: 5
                        });
                    }
                } else if (toolType === 'erlenmeyer') {
                    const flaskBaseWidth = scaledToolWidth * 1.5;
                    const flaskBodyHeight = scaledToolHeight * 0.7;
                    const flaskNeckWidth = scaledToolWidth * 0.4;
                    const flaskNeckHeight = scaledToolHeight * 0.3;

                    const body = toolGroup.findOne('Line');
                    const neck = toolGroup.findOne('Rect');

                    if (body) {
                        body.points([
                            -flaskBaseWidth / 2, flaskBodyHeight,
                            flaskBaseWidth / 2, flaskBodyHeight,
                            flaskNeckWidth / 2, 0,
                            -flaskNeckWidth / 2, 0
                        ]);
                    }
                    if (neck) {
                        neck.width(flaskNeckWidth);
                        neck.height(flaskNeckHeight);
                        neck.x(-flaskNeckWidth / 2);
                        neck.y(-flaskNeckHeight);
                    }
                    toolGroup.pivot({ x: 0, y: flaskBodyHeight });
                }
            });


            konvaStage.batchDraw();
            if (konvaEffectsLayer) konvaEffectsLayer.batchDraw();
            if (konvaToolsLayer) konvaToolsLayer.batchDraw(); // Redraw tools layer after resizing
        }

    </script>
</body>
</html>
